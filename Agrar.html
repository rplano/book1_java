<!DOCTYPE html><html lang="de"><head>
  <title>Variationen zum Thema: Java</title>
  <meta name="title" content="Variationen zum Thema: Java">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta charset="UTF-8">
  <meta name="description" content="Introduction to Java Programming">
  <meta name="keywords" content="java,introduction">
  <meta name="author" content="Ralph P. Lano">
  <meta name="robots" content="index,follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="book.css">
</head>
<body><center>
<div id="wrap">
	<ul class="sidenav">
	  <p><a href="index.html">Variationen zum Thema</a><a href="index.html">Java</a></p>
	  <li><a href="Karel.html">Karel</a></li>
	  <li><a href="Graphics.html">Graphics</a></li>
	  <li><a href="Console.html">Console</a></li>
	  <li><a href="Agrar.html">Agrar</a></li>
	  <li><a href="MindReader.html">MindReader</a></li>
	  <li><a href="Swing.html">Swing</a></li>
	  <li><a href="Asteroids.html">Asteroids</a></li>
	  <li><a href="Stocks.html">Stocks</a></li>
	</ul>
<div class="content"><p>
	<img alt="" src="images/8380f6ab-e1dc-4095-96f6-e3aa733122d7.png" style="display: block; margin-left: auto;  margin-right: auto; width: 233px; height: 223px;" /></p>
<h1>
	Agrar</h1>
<p>
	In diesem Kapitel fängt es an richtig interessant zu werden.&nbsp; Im letzten Kapitel haben wir den Top-Down Ansatz auf Kosten von Variablen etwas vernachlässigt, aber in diesem Kapitel werden wir sehen wie wir mit Methoden wieder zum Top-Down Ansatz zurückfinden.&nbsp; Und wir werden unsere ersten Animationen für Spiele schreiben.</p>
<p>
	.</p>
<h2>
	Methoden</h2>
<p>
	Wir kennen Methoden schon relativ lange, bei Karel haben wir sie noch Kommandos genannt, z.B. <em>move()</em>, <em>turnLeft()</em> und <em>frontIsClear()</em>.&nbsp; Auch in GraphicsPrograms haben wir sie benutzt, damals hießen sie auch Nachrichten die wir an ein GRect schicken, z.B. <em>setColor()</em> und <em>setFilled()</em>.&nbsp; Selbst bei &nbsp; ConsolePrograms hatten wir sie, z.B. <em>readInt()</em> und <em>println()</em>.&nbsp; Also nix neues.</p>
<p>
	Bei Karel gab es aber die coole Möglichkeit neue Kommandos zu erfinden, wie z.B. <em>turnRight()</em> oder <em>moveToWall()</em>.&nbsp; Das haben wir damals so gemacht:</p>
<pre>
  &nbsp; public void turnRight() {
        turnLeft();
        turnLeft();
        turnLeft();
    }
</pre>
<p>
	Wäre es nicht auch cool gewesen, wenn wir in unserem Target Programm folgendes neues Kommando hätten haben können:</p>
<pre>
&nbsp;   public void drawCircle( int radius, Color color ) {
        ... 
    }
</pre>
<p>
	oder für unser Wall Programm wäre eine Methode wie die folgende ganz praktisch gewesen:</p>
<pre>
  &nbsp; public void drawRowOfNBricks( int numberOfBricks ) {
        ... 
    }
</pre>
<p>
	Nun das schöne ist, das geht tatsächlich!</p>
<p>
	<strong>SEP: Methoden tun immer etwas, deswegen sollten Methoden immer Tunwörter, also Verben, sein.</strong></p>
<p>
	.</p>
<h2>
	Neue Methoden definieren</h2>
<p>
	Eine neue Methode anzulegen ist genauso einfach wie Karel neue Kommandos beizubringen.&nbsp; Der allgemeine Syntax einer Methodendeklaration ist folgender:</p>
<pre>
&nbsp;   visibility type name( parameters ) {
&nbsp;&nbsp;&nbsp;     ... body...
&nbsp;   }</pre>
<p>
	Dabei bedeutet</p>
<ul>
	<li>
		<strong>visibility:</strong>&nbsp; die Sichtbarkeit der Methode, dies ist meist entweder <em>private</em> oder <em>public</em></li>
	<li>
		<strong>type:</strong>&nbsp; der Datentyp den die Methode zurückgibt, auch Rückgabewert genannt.&nbsp; Sehr häufig ist das <em>void</em>, was soviel heißt wie nichts, also die Methode gibt nichts zurück</li>
	<li>
		<strong>name:</strong>&nbsp; der Name der Methode, hier gelten die gleichen Regeln wie für Variablen und er sollte auch immer klein geschrieben werden</li>
	<li>
		<strong>parameters:</strong>&nbsp; die Übergabe Parameter.&nbsp; Die sind neu, die gab es bei Karel noch nicht, die sind aber super praktisch wie wir gleich sehen werden</li>
</ul>
<p>
	<strong>SEP: Wenn möglich sollte die Sichtbarkeit von Methoden <em>private</em> sein.</strong></p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Archery.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Übung: Archery</h2>
<p>
	Schauen wir uns unser Archery Programm noch einmal an.&nbsp; Aber jetzt versuchen wir es mit Hilfe der Methode <em>drawCircle( int radius, Color color )</em>.&nbsp; Wir werden feststellen, dass der Code viel kürzer und auch lesbarer wird.</p>
<pre>
&nbsp;&nbsp;&nbsp; private void drawCircle(int radius, Color color) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;GOval ring = new GOval(2 * radius, 2 * radius);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ring.setColor(color);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ring.setFilled(true);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int x = 75 + 72 - radius;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(ring, x, x);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	.</p>
<h2>
	<img alt="" src="images/wall.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Übung: Wall</h2>
<p>
	Versuchen wir uns noch einmal an dem <em>Wall</em> Program, aber jetzt mit Hilfe von Methoden.&nbsp; Wir wollen also eine Mauer bestehend aus 15 Backsteinen (GRect) errichten.&nbsp; Dabei wollen wir aber die Methode</p>
<pre>
&nbsp;&nbsp;&nbsp; private void drawOneRowOfStones(int y) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int x = 50;&nbsp;&nbsp; &nbsp;// beginning x position of wall
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 5; i++) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;GRect brick = new GRect(30, 15);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(brick, x, y);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = x + 30;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}
</pre>
<p>
	verwenden.</p>
<p>
	Frage: Enthält die Methode Zauberzahlen (magic numbers)?&nbsp; Können wir das ändern?</p>
<p>
	.</p>
<h2>
	Rückgabewert</h2>
<p>
	Bisher habe wir nur Methoden gesehen, die nichts (void) zurückgeben.&nbsp; Es gibt aber auch Methoden die etwas zurückgeben.&nbsp; Meistens rechnen die Methoden etwas aus, und geben das Resultat als Rückgabewert zurück.&nbsp; Ein schönes Beispiel ist die folgende Methode die zurückgibt wieviel Inches in einer gegebenen Anzahl von Feet sind:</p>
<pre>
&nbsp;   private double feetToInches(double feet) {
        double inches = 12 * feet;
&nbsp;&nbsp;&nbsp;     return inches;
&nbsp;   }</pre>
<p>
	Wir können diese Methode jetzt in einem ConsoleProgram verwenden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/ConvertFeetToInches.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Übung: ConvertFeetToInches</h2>
<p>
	Wir wollen ein kleine ConsoleProgram schreiben, das Feet nach Inches konvertiert.&nbsp; Dazu fragt es den Benutzer nach einer Anzahl von Feet mittels <em>readDouble()</em> und&nbsp; ruft dann unsere feetToInches() Methode auf und gibt das Resultat im KonsolenFenster aus.</p>
<pre>
&nbsp;&nbsp; &nbsp;double feet = readDouble(&quot;Enter feet: &quot;);
&nbsp;&nbsp; &nbsp;double inches = <span style="color:#0000ff;">feetToInches</span>(feet);
&nbsp;&nbsp; &nbsp;println(feet + &quot; feet are &quot; + inches + &quot; inches.&quot;);
</pre>
<p>
	Wenn wir genau hinschauen, sehen wir, dass wir die feetToInches() Methode genauso verwenden wie die readInt() oder println() Methoden.&nbsp; Der einzige Unterschied ist, dass wir sie selbst geschrieben haben.</p>
<p>
	.</p>
<h2>
	Objekte als Rückgabewert</h2>
<p>
	Wir können nicht nur Zahlen als Rückgabewerte haben, sondern jeden möglichen Datentyp, also auch GRects zum Beispiel.&nbsp; Die folgende Methode generiert einen farbig augefüllte Kreis mit vorgegebenem Radius <em>r</em> an der Position <em>x</em> und <em>y</em>:</p>
<pre>
&nbsp;   private GOval createFilledCircle(int x, int y, int r, Color color) {
&nbsp;&nbsp;&nbsp;     GOval circle = new GOval(x-r, y-r, 2*r, 2*r);
&nbsp;&nbsp;&nbsp;     circle.setFilled(true);
&nbsp;&nbsp;&nbsp;     circle.setColor(color);
&nbsp;&nbsp;&nbsp;     return circle;
    }</pre>
<p>
	Wir müssen in jetzt lediglich zu unserem GraphicsProgram hinzufügen.</p>
<p>
	.</p>
<h2>
	Lokale Variablen</h2>
<p>
	Die Variablen die wir bisher kennengelernt haben nennen wir auch <em>lokale</em> Variablen.&nbsp; Lokal im Bezug auf eine Methode.&nbsp; Das soll heißen, dass Variablen nur in der Methode sichtbar sind in der sie deklariert wurden, außerhalb, also in anderen Methoden sind sie nicht sichtbar.&nbsp; Betrachten wir das an einem Beispiel:</p>
<pre>
public class LocalVariables extends ConsoleProgram {

&nbsp;&nbsp; &nbsp;public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double feet = readDouble(&quot;Enter feet: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(feet);
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;private void feetToInches() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double inches = 12;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(inches);
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	In dem Beispiel gibt es eine Variable <em>feet</em> die in der Methode <em>run()</em> existiert und eine Variable <em>inches</em> die in der Methode <em>feetToInches()</em> existiert.&nbsp; Wenn wir versuchen in der Methode <em>feetToInches()</em> auf die Variable feet zuzugreifen, dann geht das nicht.&nbsp; Umgekehrt gilt das gleiche.&nbsp; Die Variablen sind also nur lokal in ihren jeweiligen Methoden sichtbar.</p>
<p>
	Wie wir aber gesehen haben ist es aber viel besser wenn wir von einer Methode auf die Variablen einer anderen Methode zugreifen können.&nbsp; Deswegen benötigen wir Parameter.&nbsp;</p>
<pre>
&nbsp;&nbsp; &nbsp;private void feetToInches(double feet) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double inches = 12 * feet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(inches);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Mit den Parametern übergeben wir Variablen von einer Methode an eine andere, deswegen nennt man sie auch Übergabeparameter.&nbsp;</p>
<p>
	<img alt="" src="images/LocalVariables.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Allerdings wird nur eine Kopie der Variablen übergeben.&nbsp; Um das zu sehen, schauen wir uns das folgende Programm kurz an:</p>
<pre>
public class LocalVariables extends ConsoleProgram {

&nbsp;&nbsp; &nbsp;public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double <span style="color:#0000ff;">feet</span> = readDouble(&quot;Enter feet: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;feetToInches(<span style="color:#0000ff;">feet</span>);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(<span style="color:#0000ff;">feet</span>);
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;private void feetToInches(double <span style="color:#ff0000;">feet</span>) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#ff0000;">feet</span> = 42;
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Erst bitten wir den Benutzer uns einen Wert zu geben, z.B. &#39;12&#39;.&nbsp; Diesen Wert übergeben wir an die Methode <em>feetToInches()</em>.&nbsp; Wenn wir dann aber sagen, dass <span style="font-family:courier new,courier,monospace;">feet = 42</span> sein soll, dann gilt das aber nur für die Kopie, das Original bleibt unversehrt, wie wir sehen wenn wir uns anschauen was im Konsolenfenster ausgegeben wird.&nbsp; Dort erscheint nämlich die &#39;12&#39;.</p>
<p>
	Deswegen ist es eigentlich auch egal, ob wir das rote <em>feet</em> auch <em>feet</em> nennen oder ihm einen anderen Namen geben:</p>
<pre>
public class LocalVariables extends ConsoleProgram {

&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double feet = readDouble(&quot;Enter feet: &quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feetToInches(feet);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(feet);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void feetToInches(double <span style="color:#ff0000;">fritz</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#ff0000;">fritz</span> = 42;
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>
	Jetzt wird hoffentlich auch klar, warum wir einen Rückgabewert benötigen.&nbsp; Denn wenn in der aufgerufenen Methode <em>feetToInches()</em> irgendetwas ausgerechnet wird, dann ist das nur lokal in der Methode sichtbar.&nbsp; Damit wir es wieder zurück in die aufrufende Methode bekommen, benötigen wir den Rückgabewert.</p>
<p>
	Eine Anmerkung noch: eine Methode kann mehrere Parameter haben, sie kann aber nur einen Rückgabewert haben.</p>
<p>
	.</p>
<h2>
	Übung: Parameter und Rückgabewert mit Jeliot</h2>
<p>
	Nach diesen Erklärungen ist es sinnvoll sich das ConvertFeetToInches Beispiel in Jeliot anzuschauen.</p>
<p>
	Figure</p>
<p>
	.</p>
<h2>
	Animation</h2>
<p>
	So, jetzt haben wir Methoden in unserer Toolbox.&nbsp; Das ist super, denn damit können wir anfangen wirklich coole Sachen zu machen, nämlich Animationen und Spiele.&nbsp; Wir fangen mit Animationen an.&nbsp; Dafür brauchen wir aber noch eine Sache.</p>
<p>
	.</p>
<h2>
	GObject</h2>
<p>
	Erinnern wir uns an die Grafik Klassen die wir im zweiten Kapitel kennengelernt haben: GRect, GOval, GLine, GImage, GLabel, GArc und GPolygon.&nbsp; Diese Klassen sind nicht ganz unabhängig voneinandern, sondern sie haben sogar etwas gemeinsam, sie sind nämlich alle GObjects.</p>
<p>
	<img alt="" src="images/ACM_Hierarchy.png" style="margin-left: 10px; margin-right: 10px; width: 438px; height: 100px;" /></p>
<p>
	Die Klasse GObject nennt man auch Elternklasse.&nbsp; Und man sagt auch die Kinderklassen wie GRect und GOval erben von ihrer Elternklasse.&nbsp; Was erben sie?&nbsp; Die Methoden der Elternklasse.&nbsp; Das ist super praktisch wie wir sehen werden.&nbsp; Aber erst einmal schauen wir uns an welche Methoden das sind:</p>
<ul>
	<li>
		<strong>setLocation(x, y):</strong>&nbsp; schiebt ein GObject an die Stelle x, y</li>
	<li>
		<strong>move(dx, dy):</strong>&nbsp; verschiebt ein GObject um dx und dy</li>
	<li>
		<strong>getX():</strong>&nbsp; gibt die x Koordinate des GObjects</li>
	<li>
		<strong>getY():</strong>&nbsp; gibt die y Koordinate des GObjects</li>
	<li>
		<strong>getWidth():</strong>&nbsp; gibt die Breite des GObjects</li>
	<li>
		<strong>getHeight():</strong>&nbsp; gibt die Höhe des GObjects</li>
	<li>
		<strong>setColor(col):</strong>&nbsp; ändert die Farbe des GObjects</li>
	<li>
		<strong>sendToFront():</strong>&nbsp; schickt eine GObject nach vorne (z-order)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</li>
	<li>
		<strong>sendToBack():</strong>&nbsp; schickt eine GObject nach hinten (z-order)</li>
</ul>
<p>
	Also alle Grafik Klassen die wir bisher kennengelernt haben, haben diese Methoden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/billiards.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 229px; float: right;" />Übung: Animationen mit dem Game Loop</h2>
<p>
	Für unsere erste Animation haben wir uns Billiard ausgesucht: Wir wollen, dass sich eine scharze Kugel über den Tisch bewegt, und an den Seiten reflektiert wird.</p>
<p>
	Jede Animation hat einen &quot;<em>Game Loop</em>&quot;.&nbsp; Unsere <em>run()</em> Methode sieht wie folgt aus:</p>
<pre>
&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setup();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// game loop
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">while (true) {</span>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;moveBall();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;checkForCollisionsWithWall();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">pause(40);</span>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Alles was mit dem Setup und der Initialisierung zu tun hat, kommt in die <em>setup()</em> Methode.&nbsp; Danach beginnt der <em>Game Loop</em>: das ist effektiv eine Endlosschleife.&nbsp; In dieser Endlosschleife werden verschiedene Schritte ausgeführt, wie z.B. <em>moveBall()</em> und <em>checkForCollisionsWithWall()</em>.&nbsp; Am Ende jedes Durchgangs wird die <em>pause()</em> Methode aufgerufen.&nbsp; Diese wartet einfach eine vorgegeben Anzahl von Millisekunden.&nbsp; In diesem Fall also 40 ms, was einer Framerate von 25 fps entspricht.</p>
<p>
	Gehen wir jetzt weiter die Methoden im Einzelnen durch.&nbsp; In der <em>setup()</em> Methode legen wir die Größe des Fensters fest, danach setzen wir die Hintergrundfarbe auf grün, und schließlich kreiiren wir einen Ball:</p>
<pre>
&nbsp;&nbsp;&nbsp; private void setup() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setSize(WIDTH, HEIGHT);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setBackground(Color.GREEN);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ball = new GOval(BALL_SIZE, BALL_SIZE);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ball.setFilled(true);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(ball, WIDTH / 2, HEIGHT / 2);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Was auffallen sollte hier ist, dass es &quot;ball =&quot; und nicht &quot;GOval ball =&quot; heißt.&nbsp; Dazu gleich mehr.&nbsp; Die nächste Methode ist die <em>moveBall()</em> Methode:</p>
<pre>
&nbsp;&nbsp;&nbsp; private void moveBall() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ball.move(vx, vy);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Die ist ganz einfach, wir rufen einfach die <em>move()</em> Methode der Klasse GOval auf.&nbsp; Interessant auch hier wieder, weder <em>ball</em> noch <em>vx</em> oder <em>vy</em> werden deklariert.&nbsp; Und schließlich sehen wir uns die <em>checkForCollisionsWithWall()</em> Methode an:</p>
<pre>
&nbsp;&nbsp;&nbsp; private void checkForCollisionsWithWall() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double x = ball.getX();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double y = ball.getY();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ((x &lt; 0) || (x &gt; WIDTH)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -vx;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ((y &lt; 0) || (y &gt; HEIGHT)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vy = -vy;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Wir lassen uns die momentane <em>x-</em> und <em>y</em>-Position des Balls geben, und testen ob diese innerhalb des Spielfeldes ist.&nbsp; Falls nicht, dann ändern wir das Vorzeichen der Geschwindigkeit.&nbsp; Wenn man möchte, könnte man die Geschwindigkeit bei jeder Kollision ein wenig reduzieren, tun wir aber nicht.</p>
<p>
	Kommen wir jetzt zu dem Problem mit der fehlenden Deklaration von <em>ball</em>, <em>vx</em> und <em>vy</em>.&nbsp; Bisher kennen wir nur <em>lokale</em> Variablen.&nbsp; Das Problem mit lokalen Variablen ist, dass sie nur innerhalb einer Methode gültig sind.&nbsp; In unserem Billiard Beispiel, brauchen wir aber den Ball in drei Methoden: der <em>setup()</em>, der <em>moveBall()</em>, und der <em>checkForCollisionsWithWall()</em> Methode.&nbsp; Offensichtlich können wir also für den Ball (und auch <em>vx</em> und <em>vy</em>) keine lokale Variable verwenden.&nbsp; Anstelle verwenden wir eine <em>Instanzvariable</em>.&nbsp; Instanzvariablen werden am Anfang der Klasse deklariert, vor der run() Methode, und ganz wichtig, außerhalb der run() Methode (oder irgendeiner anderen Methode):</p>
<pre>
public class Billiards extends GraphicsProgram {
    // instance variables
&nbsp;&nbsp; &nbsp;private GOval ball;
&nbsp;&nbsp; &nbsp;private int vx = 4;
&nbsp;&nbsp; &nbsp;private int vy = -3;

    public void run() { 
        ...
    }
    ...
}
</pre>
<p>
	Der Vorteil von Instanzvariablen ist, dass in jeder Methode auf sie zugegriffen werden kann.&nbsp; Im nächsten Kapitel werden wir noch mehr zu Instanzvariablen erfahren.</p>
<p>
	.</p>
<h2>
	Events</h2>
<p>
	Also Animationen waren gar nicht so schwer.&nbsp; Kommen wir zu den Spielen: unsere Spiele sollen mit der Maus steuerbar sein.&nbsp; Dazu müssen wir zwei Sachen tun, wir müssen dem Programm sagen,</p>
<ol>
	<li>
		dass es auf die Maus hören soll und</li>
	<li>
		welche der Maus Events uns interessieren, zB. ob die Maustaste gedrückt wurde oder die Maus bewegt wurde.</li>
</ol>
<p>
	Das erste erreichen wir indem wir am Anfang unseres Programms die Methode</p>
<pre>
    addMouseListeners();</pre>
<p>
	aufrufen.&nbsp; Das zweite erreichen wir indem wir eine von zwei Methoden überschreiben:&nbsp; Wenn wir hören wollen, ob die Maustaste gedrückt wurde, dann verwenden wir</p>
<pre>
    public void mousePressed(MouseEvent e) { ... }</pre>
<p>
	oder wenn wir hören wollen ob sich die Maus bewegt hat, dann verwenden wir</p>
<pre>
    public void mouseMoved(MouseEvent e) { ... }</pre>
<p>
	Wir können natürlich auch beide verwenden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/builder.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 229px; float: right;" />Übung: Builder</h2>
<p>
	Builder ist von Lego inspiriert: wir haben kleine Klötzchen (blocks) und die können wir beliebig auf dem Bildschirm setzen, in dem wir mit der Maus an die Position klicken wo der Klotz hin soll.&nbsp; Der Programmcode dafür ist total einfach.&nbsp; Als erstes müssen wir dem Programm sagen, dass wir auf die Maus hören möchten:</p>
<pre>
&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">addMouseListeners();</span>
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Danach müssen wir nur noch sagen, was denn passieren soll, wenn die Maus geklickt wurde:</p>
<pre>
&nbsp;&nbsp;&nbsp; public void <span style="color:#0000ff;">mousePressed</span>(MouseEvent e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int x = e.getX();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int y = e.getY();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;GRect block = new GRect(BLOCK_SIZE, BLOCK_SIZE );
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;block.setColor(Color.RED);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(block, x, y);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Als Erstes benötigen wir die x- und y-Position der Maus: die erhalten wir vom <em>MouseEvent</em> e.&nbsp; Der MouseEvent hat zwei Methoden, <em>getX()</em> und <em>getY()</em> und diese beiden Methoden geben uns die x- und y-Position der Maus.&nbsp; Sobald wir die haben kreiiren wir ein neues GRect und platzieren es an die Position der Maus.</p>
<p>
	Mit einem kleine Trick, kann man die Position der Klötzchen &quot;quantisieren&quot;:</p>
<pre>
        x = x / BLOCK_SIZE * BLOCK_SIZE;</pre>
<p>
	Das funktioniert allerdings nur wenn <em>x</em> vom Datentyp <em>int</em> ist.&nbsp; Warum funktioniert das?</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/mouseTracker.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Übung: MouseTracker</h2>
<p>
	Was wir noch brauchen, ist der Mausbewegung zu verfolgen.&nbsp; Wie das geht demonstriert das folgende Programm.&nbsp; Wir beginnen wieder mit der <em>run()</em> Methode:</p>
<pre>
&nbsp;&nbsp;&nbsp; // instance variables
    private GLabel lbl;

&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl = new GLabel(&quot;&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl.setFont(&quot;Arial-bold-20&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(lbl, 0, 0);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;addMouseListeners();
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Um die Position der Maus anzuzeigen wollen wir einen GLabel namens <em>lbl</em> verwenden.&nbsp; Der ist eine Instanzvariable und muss initialisiert werden und zu unserem Canvas hinzugefügt werden.&nbsp; Danach sagen wir unserem Programm wieder, dass wir auf Maus Ereignisse hören möchten.&nbsp; In diesem Beispiel wollen wir wissen ob die Maus sich bewegt hat, deswegen übersschreiben wir die <em>mouseMoved()</em> Methode:</p>
<pre>
&nbsp;&nbsp;&nbsp; public void <span style="color:#0000ff;">mouseMoved</span>(MouseEvent e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int x = e.getX();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int y = e.getY();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl.setLabel(&quot;x=&quot; + x + &quot;,y=&quot; + y);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl.setLocation(x, y);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Wir holen uns wieder die x- und y-Position der Maus, ändern den Text des Labels mit der <em>setLabel()</em> Methode, und verschieben den Label mit der <em>setLocation()</em> Methode an die Postion der Maus.&nbsp; Und das war&#39;s auch schon.</p>
<p>
	.</p>
<h2>
	RandomGenerator</h2>
<p>
	Für viele Spiele benötigen wir Zufallszahlen.&nbsp; Dafür gibt es die Klasse <em>RandomGenerator</em>.&nbsp; Die kann nicht nur Zufallszahlen, sondern auch Zufallsfarben erzeugen.&nbsp; Der Code</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; RandomGenerator rgen = new RandomGenerator();
        ...
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double width = rgen.nextDouble(0, 150);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Color col = rgen.nextColor();
</pre>
<p>
	zeigt wie man Zufallszahlen und Zufallsfarben erzeugt.&nbsp; Es gibt auch die Methoden nextInt(a,b) und nextBoolean().</p>
<p>
	.</p>
<h2>
	GCanvas</h2>
<p>
	An dieser Stelle macht es noch Sinn eine Klasse vorzustellen, die wir noch nicht explizit kennengelernt haben: die Klasse GCanvas.&nbsp; Verwendet haben wir sie aber schon, und zwar als wir unser GRect <em>lisa</em> hinzugefügt haben mit</p>
<pre>
    add(lisa, 70, 50);</pre>
<p>
	Die Frage die wir uns damals nämlich hätten stellen sollen ist wozu?&nbsp; Und die Antwort ist natürlich: zum GCanvas.&nbsp; GCanvas ist unser Filzbrett.&nbsp; Wenn wir was hinzufügen können, stellt sich als nächstes gleich die Frage, können wir auch was wegnehmen?&nbsp; Und was können wir denn sonst noch so machen mit dem GCanvas?&nbsp; Auch dafür gibt es eine Liste von Methoden:</p>
<ul>
	<li>
		<strong>add(object):</strong>&nbsp; fügt eine GObject zum GCanvas hinzu</li>
	<li>
		<strong>add(object, x, y):</strong>&nbsp; fügt eine GObject zum GCanvas an der Position x, y hinzu</li>
	<li>
		<strong>remove(object):</strong>&nbsp; entfernt das GObject object von GCanvas</li>
	<li>
		<strong>removeAll():</strong>&nbsp; entfernt alle GObjects von GCanvas</li>
	<li>
		<strong>getElementAt(x, y):</strong>&nbsp; gibt uns das vorderste GObject an der Position x, y, falls dort eines ist</li>
	<li>
		<strong>setBackground(c):</strong>&nbsp; ändert die Hintergrundfarbe des GCanvas</li>
</ul>
<p>
	Außerdem, ist ein GCanvas auch ein GObject, d.h. alles was GObject kann, kann auch GCanvas.</p>
<p>
	.</p>
<hr />
<h1>
	Review</h1>
<p>
	Eigentlich haben wir dieses Kapitel gar nicht so viel gemacht.&nbsp; Aber das ist nicht ganz richtig, in den Projekten werden wir gleich sehen, dass wir schon wirklich coole Sachen programmieren können.&nbsp; Was haben wir bisher in diesem Kapitel gelernt?&nbsp; Wir wissen jetzt was</p>
<ul>
	<li>
		Methoden</li>
	<li>
		Paremeter</li>
	<li>
		Rückgabewert</li>
	<li>
		und lokale Variablen</li>
</ul>
<p>
	sind.&nbsp; Ausserdem haben wir</p>
<ul>
	<li>
		GObject</li>
	<li>
		GCanvas</li>
	<li>
		und den RandomGenerator</li>
</ul>
<p>
	kennengelernt.&nbsp; Das wichtigste in diesem Kapitel war, dass wir Animation mit dem <em>GameLoop</em> erreichen können und auf Maus Events reagieren können.</p>
<p>
	.</p>
<hr />
<h1>
	Projekte</h1>
<p>
	Die Projekte in diesem Kapitel fangen an richtig Spass zu machen.&nbsp; Los geht&#39;s.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/stairs.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Stairs</h2>
<p>
	Unser erstes Projekt ist eine kleine Treppe.&nbsp; Das Problem ist ganz ähnlich wie das Wall Problem.&nbsp; Daher macht es auch hier Sinn nach dem Top-Down Ansatz anzunehmen es gibt eine Methode drawRowOfNBricks<em>(int n)</em> gibt.&nbsp; Wir sollten auch darauf achten keine <em>magic numbers</em> zu verwenden, sondern nur Konstanten.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/pyramid2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Pyramid</h2>
<p>
	Die Pyramide ist fast identisch zur Treppe.&nbsp; Der einzige Unterschied ist, dass die Stufen immer einen halben Stein versetzt sind.&nbsp; Die Treppe soll neun Steine in der untersten Reihe haben.&nbsp; Eigentlich brauchen wir den Code vom letzten Beispiel nur geringfügig zu ändern.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/chessBoard.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 229px; float: right;" />ChessBoard</h2>
<p>
	Kehren wir zu unserem Schachbrett zurück.&nbsp; Dieses Mal wollen wir aber den Top-Down Ansatz verwenden.&nbsp; Dazu gibt es mehrere Ansätz, aber einer wäre eine Methode namens <em>drawOneRow()</em> zu deklarieren.&nbsp; Hier muß man sich genau überlegen welche Parameter man an die Methode übergibt.&nbsp; Man könnte auch zwei Methoden haben, eine für gerade und eine für ungerade Zeilen.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/RGBColor.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />RGBColor</h2>
<p>
	Wir haben ja schon den Regenbogen gezeichnet, allerdings noch sehr &quot;händisch&quot;.&nbsp; Jetzt wollen wir die HSV Farbpalette zeichnen [5].&nbsp; In Java kann man eine beliebige Farbe mittels</p>
<pre>
    Color col = new Color(r, g, b);</pre>
<p>
	erzeugen, wobei die Variablen r, g, und b jeweils für den rot, grün und blau Anteil stehen.&nbsp; Diese müssen Werte zwischen 0 und 255 sein.&nbsp; Also z.B. Rot wird durch</p>
<pre>
    Color colRed = new Color(255, 0, 0);</pre>
<p>
	erzeugt.</p>
<p>
	Wenn wir uns die Farben in der HSV Farbpalette genau ansehen bemerken wir, dass es beginnend mit Rot über die Farben Gelb, Grün, Cyan, Blau, Magenta wieder zu Rot zurück kommt.&nbsp; Insgesamt gibt es also 6 Farbabstufungen.&nbsp; Den ersten Übergang von Rot nach Gelb, könnte man z.B. durch folgende Zeilen erreichen:</p>
<pre>
    for (int x = 0; x &lt; 255; x++) {
        Color col = new Color(255, x, 0);
        GLine line = new GLine(x, 0, x, HEIGHT);
        line.setColor(col);
        add(line);
    }</pre>
<p>
	.</p>
<h2>
	<img alt="" src="images/Moire.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 233px; float: right;" />Moire</h2>
<p>
	Der Moiré-Effekt [6] ist normalerweise eher unerwünscht, aber er kann auch ganz hübsch sein.&nbsp; Man teilt zunächst die Länge und Breite in gleiche Teile auf, z.B. 11.&nbsp; Dann zeichnet man von jedem Punkt oben zu jedem Punkt unten eine Linie und das Gleiche von links nach rechts.&nbsp; Am besten man zeichnet sich erst einmal auf einem Stück Papier auf wie man selbst das zeichnen würde.&nbsp; Es läuft auf zwei verschachtelte <em>for</em> Scheifen hinaus.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/randomSquares.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />RandomSquares</h2>
<p>
	Wir wollen uns weiter künstlerisch betätigen.&nbsp; Es geht darum verschieden farbige Rechtecke von zufälliger Größe und Position zu zeichnen.&nbsp; Man benutzt natürlich den RandomGenerator.&nbsp; Zunächst lässt man sich eine zufällige Breite und Höhe für ein GRect geben.&nbsp; Diese sollten vielleicht nicht zu groß oder zu klein sein.&nbsp; Dann gibt man dem Rechteck eine zufällige Farbe mit</p>
<pre>
    rect.setFillColor(rgen.nextColor());</pre>
<p>
	Un schließlich plaziert man es noch an eine zufällige x und y Position.&nbsp; Das Ganze kommt dann in eine Endlosschleife und man wartet vielleicht 100 ms.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/TwinkleTwinkle.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />TwinkleTwinkle</h2>
<p>
	Bei TwinkleTwinkle geht es darum einen zufälligen Sternenhimmel zu generieren.&nbsp; Die Sterne sind GOvals mit eine zufälligen Größe zwischen 1 und 4 Pixeln.&nbsp; Die werden zufällig auf dem Canvas verteilt.&nbsp; Vorher sollte man noch den Hintergrund mittels</p>
<pre>
    setBackground(Color.BLACK);</pre>
<p>
	auf Schwarz setzen.&nbsp; Das Ganze kommt dann in eine Endlosschleife und man wartet vielleicht 500 ms bis zur Erzeugung des nächsten Sterns.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/confetti.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Confetti</h2>
<p>
	Wir alle lieben Confetti.&nbsp; Dabei sind die ganz einfach zu machen, entweder mit einem Locher oder mit GOvals.&nbsp; Die Confetti können alle gleich groß sein (z.B. 20 Pixel), müssen es aber nicht.&nbsp; Aber auf jeden Fall haben sie verschiedene Farben, wieder ein Fall für den RandomGenerator.&nbsp; Und natürlich sollte die Postion der Confetti zufällig sein, also das Ganze kommt wieder in eine Endlosschleife.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/animatedPacman.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />AnimatedPacman</h2>
<p>
	Wir haben ja schon vor zwei Kapiteln unseren ersten PacMan gemalt.&nbsp; Der war aber noch recht statisch.&nbsp; Wir wollen PacMan jetzt animieren.&nbsp; Dazu ist es nützlich zu wissen, dass es die beiden Kommandos für GArcs</p>
<pre>
    pacman.setStartAngle(angle);
    pacman.setSweepAngle(360 - 2 * angle);</pre>
<p>
	gibt.&nbsp; Wenn wir jetzt die <em>angle</em> Variable zwischen 0 und 40 variieren lassen, und das alle 50 ms tun, dann erscheint das so wie wenn PacMan animiert wäre.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/trafficLight2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />TrafficLight</h2>
<p>
	Auch die Ampel haben wir bereits vor zwei Kapiteln gezeichnet.&nbsp; Jetzt wollen wir aber die Ampel animieren.&nbsp; Die Ampel beginnt mit Rot, geht dann über zu Rot-Gelb, gefolgt von Grün.&nbsp; Schließlich geht es wieder über Gelb zurück nach rot.&nbsp; Der Übergang sollte jeweils eine Sekunde dauern, und das Ganze sollte wieder in einer Endlosschleife verpackt sein.&nbsp; Man könnte z.B. Instanzvariablen für die Lichter haben, und diese dann mittels</p>
<pre>
&nbsp;&nbsp; &nbsp;if (currentLight == 0) {
        redLight.setColor(Color.RED);
        yellowLight.setColor(Color.BLACK);
        greenLight.setColor(Color.BLACK);
    } ...
</pre>
<p>
	ein- und ausschalten.&nbsp; Jetzt muss man sich noch überlegen wie man zwischen den verschiedenen Zuständen hin- und herschaltet.&nbsp; Das kann man sehr geschickt mit dem Remainder Operator % machen:</p>
<pre>
        currentLight++;
        currentLight = currentLight % 4;</pre>
<p>
	.</p>
<h2>
	<img alt="" src="images/analogClock.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 228px; float: right;" />AnalogClock</h2>
<p>
	In der <em>setup()</em> Methode zeichnen wir den Kreis und die Uhrzeiten mittels GLabels.&nbsp; Dabei kann man die GLabels von Hand setzen, oder mittels Sinus und Kosinus ausrechnen wo sie denn am besten hinpassen.&nbsp; Beides dauert ungefähr gleich lange, das zweitere bedarf aber etwas mehr Gehirnschmalz.</p>
<p>
	Allerdings wenn es darum geht die Zeiger zu zeichnen, kommen wir am Sinus und Kosinus [7] nicht mehr vorbei.&nbsp;</p>
<pre>
    private void drawSeconds(int seconds) {
        double radians = 2 * Math.PI * seconds / 60;
        double lengthSecondHand = 250;
        double x = SIZE / 2 + Math.sin(radians) * lengthSecondHand / 2;
        double y = SIZE / 2 - Math.cos(radians) * lengthSecondHand / 2;
        secondsHand.setEndPoint(x, y);
    }</pre>
<p>
	dabei handelt es sich bei <em>secondsHand</em> um eine GLine</p>
<pre>
    private GLine secondsHand;</pre>
<p>
	die als Instanzvariable deklariert wurde.&nbsp; Wie wir an die Stunden, Minuten und Sekunden kommen, haben wir ja bereits in dem Projekt &quot;Time&quot; des letzten Kapitel gesehen.&nbsp; Da die Uhr natürlich animiert sein soll, brauchen wir natürlich eine Endlosschleife, mit einer Pause von einer Sekunde, evtl sogar nur einer halben Sekunde.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/drunkenWalk.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />DrunkenWalk</h2>
<p>
	Wenn Karel mal einen über den Durst getrunken hat, dann läuft er nicht mehr so gerade.&nbsp; In diesem Beispiel fängt er in der Mitte an.&nbsp; Einmal pro Sekunde macht er dann einen Schritt, zufälliger Distanz in eine beliebige Richtung.&nbsp; Wobei er natürlich in einem Schritt nicht beliebig weit kommt.&nbsp; Mit GLines zeichnen wir die Schlangenlinien nach, um Karel am nächsten Morgen zu zeigen, dass er doch besser ein Taxi hätte nehmen sollen.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/tree.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />Tree*</h2>
<p>
	Bäume zu zeichnen stellt sich als relativ schwierig heraus.&nbsp; Eine beliebt Technik um dieses Problem zu lösen ist die Rekursion.&nbsp; Da wir aber noch nichts von Rekursion gehört haben, versuchen wir einen Baum ohne Rekursion zu zeichnen.&nbsp; Nach dieser Erfahrung, sind wir vielleicht motivierter im nächsten Semester die Geheimnisse der Rekursion kennen zu lernen.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/asteroidCreator.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />AsteroidCreator</h2>
<p>
	Das Arcade-Spiel &#39;AsteroidCreator&#39; war ein absoluter Hit in den späten 80er Jahren. In dem Spiel geht es darum, an der Stelle an der die Benutzerin mit der Maus klickt einen Asteroiden zu zeichnen.&nbsp; Dabei sind Asteroiden einfach GRects unterschiedlicher, zufälliger Größe mit schwarzem Rand.&nbsp; Wir müssen also wieder die <em>addMouseListeners()</em> Methode im Setup aufrufen.&nbsp; In der <em>mousePressed()</em> Methode malen wir dann einfach ein Rechteck an der Position an der die Benutzerin mit der Maus geklickt hat.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/connectTheClicks.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />ConnectTheClicks</h2>
<p>
	Ganz ähnlich wie das vorherige Spiel war auch &#39;ConnectTheClicks&reg;&#39; sehr populär in den späten 70er Jahren.&nbsp; Dabei handelt es sich um ein Spiel in dem der Benutzer mit der Maus an eine Stelle klickt, und diese dann mit der vorhergehenden verbunden wird.&nbsp; Was das Spiel etwas komplizierter macht, ist dass man sich merken muss, an welche Stelle der Benutzer vorher geklickt hat.&nbsp; Dazu verwenden wir einfach zwei Instanzvariablen:</p>
<pre>
    private int x0 = -1;
    private int y0 = -1;</pre>
<p>
	Wenn wir die Variablen mit dem Wert &quot;-1&quot; initialisieren, dann ist das ein kleiner Trick mit dem wir feststellen können, ob das der erste Klick ist.&nbsp; Denn dann dürfen wir noch keine Linie ziehen!&nbsp; Ansonsten, zeichnen wir einfach eine Linie (GLine) bei jedem Klick von der alten Position auf die neue Maus-Position.&nbsp;</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/tictactoe.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 216px; float: right;" />TicTacToe</h2>
<p>
	TicTacToe kennt jeder aus dem Kindergarten oder der Schule, notfalls kann man in der Wikipedia dazu folgendes nachlesen [9]:</p>
<p>
	&quot;Auf einem quadratischen, 3&times;3 Felder großen Spielfeld setzen die beiden Spieler abwechselnd ihr Zeichen (ein Spieler Kreuze, der andere Kreise) in ein freies Feld. Der Spieler, der als Erster drei Zeichen in eine Zeile, Spalte oder Diagonale setzen kann, gewinnt.&quot;</p>
<p>
	Im <em>setup()</em> zeichnen wir den Hintergrund, am einfachsten ist das als Bild, und sorgen mittels <em>addMouseListeners()</em>, dass wir auf Maus Ereignisse hören.&nbsp; Dazu müssen wir noch die <em>mousePressed()</em> Methode hinzufügen.&nbsp; Dort müssen wir dann einfach abwechselnd ein &quot;X&quot; oder ein &quot;O&quot; malen, je nachdem wer dran ist.&nbsp; Wie weiß man wer dran ist?&nbsp; Das kann man z.B. über eine Instanzvariable machen:</p>
<pre>
    private int currentPlayer = 1;</pre>
<p>
	Die darf zwei Werte haben, &#39;1&quot; für Spieler eins und &quot;2&quot; für Spieler zwei.&nbsp; Das Umschalten zwischen den beiden Spielern geht dann ganz einfach über:</p>
<pre>
        if (currentPlayer == 1) {
            ...
            currentPlayer = 2;
        } else {
            ...
            currentPlayer = 1;
        }</pre>
<p>
	Eine kleine Sache noch die ganz praktisch ist: man kann natürlich einfach die &quot;X&quot; und &quot;O&quot; da malen wo der Nutzer geklickt hat.&nbsp; Das schaut dann aber etwas schepps aus.&nbsp; Hier kann man einmal von der Integer Division profitieren:</p>
<pre>
    public void mousePressed(MouseEvent e) {
        int x = e.getX();
        int i = x / CELL_WIDTH;
        int xPos = i * CELL_WIDTH;
        ...
    }</pre>
<p>
	.</p>
<hr />
<h1>
	Challenges</h1>
<p>
	.</p>
<h2>
	<img alt="" src="images/agar3.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />Agrar</h2>
<p>
	Das Spiel Agrar ist inspiriert von dem Spiel Agar.io, Dabei geht es laut Wikipedia [10] darum:</p>
<p>
	&quot;... eine Zelle zu navigieren, die dadurch wächst, dass sie Pellets und andere Zellen frisst. Sie darf dabei jedoch nicht selbst von größeren Zellen gefressen werden.&quot;</p>
<p>
	Unsere Version des Spiels ist etwas einfacher, es gibt nämlich nur eine Zelle, und die kann nur Pellets futtern.&nbsp; Aber das ist auch schon recht anspruchsvoll.</p>
<p>
	Wir brauchen zunächst eine Instanzvariable für die Zelle:</p>
<pre>
    private GOval cell;</pre>
<p>
	Die initialisieren wir in der <em>setup()</em> Methode, dort fügen wir auch den MouseListener hinzu.&nbsp; Als nächstes benötigen wir den <em>GameLoop</em>:</p>
<pre>
    while (true) { // game loop
        createRandomFood();
        checkForCollision();
        pause(DELAY);
    }</pre>
<p>
	in dem wir an einer zufälligen Position ein Pellet, also ein GOval mit zufälliger Farbe erzeugen.&nbsp; Als nächstes schauen wir ob es zwischen Zelle und Pellet zu einer Kollision gekommen ist.&nbsp; Wie wissen wir ob es zu einer Kollision gekommen ist?&nbsp; Dafür gibt es die Methode <em>getElementAt()</em>:</p>
<pre>
    GObject collisonObject = <span style="color:#0000ff;">getElementAt(x, y)</span>;
    if ( (collisonObject != <span style="color:#0000ff;">null</span>) &amp;&amp; (collisonObject != cell) ) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;double w = cell.getWidth();
        cell.setSize(w + 1, w + 1);
        remove(collisonObject);
    }              </pre>
<p>
	Diese Methode schaut ob sich an der Position x,y etwas befindet.&nbsp; Wenn da nichts ist, dann gibt die Methode den Wert &quot;null&quot; zurück.&nbsp; Ansonsten gibt sie uns das Objekt zurück, das sich an dieser Position befindet.&nbsp; Das könnte ein Pellet sein, das könnte aber auch die Zelle selbst sein.&nbsp; Deswegen müssen wir checken, dass es nicht &quot;null&quot; ist, und dass es nicht die Zelle ist.&nbsp; Da es ja sonst nichts gibt, wissen wir jetzt, dass das <em>collisonObject</em> ein Pellet sein muss.&nbsp; Das Pellet &quot;essen&quot; wir dann, was bedeutet, dass die Zelle fetter wird, und das die Pellet verschwindet.</p>
<p>
	Und natürlich müssen wir noch die <em>mouseMoved()</em> Methode implementieren.&nbsp; Die ist aber ganz einfach, weil wir einfach die Zelle an die Position der Maus bewegen:</p>
<pre>
    public void mouseMoved(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();
        cell.setLocation(x, y);
    }</pre>
<p>
	.</p>
<h2>
	<img alt="" src="images/tetris.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 205px; float: right;" />Tetris</h2>
<p>
	Tetris ist inzwischen ein Spiele Klassiker.&nbsp; Ursprünglich wurde es vom russischen Programmierer Alexei Paschitnow programmiert [11].&nbsp; Tetris besitzt verschiedene Steinformen die etwas lateinischen Buchstaben ähneln (I, O, T, Z und L).&nbsp; Die Spieler müssen die einzelnen Steine die vom oberen Rand des Spielfelds herunterfallen in 90-Grad-Schritten drehen und sie so verschieben, dass sie am unteren Rand horizontale, möglichst lückenlose Reihen bilden.&nbsp; Wie üblich beschränken wir uns auf eine etwas einfachere Version, in der es nur vier Steinformen gibt: einen Einer-Block, einen horizontalen und einen vertikalen Zweier-Block, und einen Vierer-Block.&nbsp; Drehen kann man die Blöcke in unserer einfachen Version nicht.</p>
<p>
	In der <em>setup()</em> Methode legen wir einen neuen Stein an:</p>
<pre>
    private void setup() {
        createNewBrick();
    }</pre>
<p>
	Die Methode <em>createNewBrick()</em> legt einen zufälligen neuen Stein an.&nbsp; Abhängig von einer Zufallszahl wird jeweils eine andere Steinform erzeugt:</p>
<pre>
    private void createNewBrick() {
        switch (rgen.nextInt(0, 3)) {
        case 0:
            brick = new GRect(WIDTH / 2, 0, BRICK_SIZE, BRICK_SIZE * 2);
            break;
        case 1:
            ...
        }
        brick.setFilled(true);
        brick.setFillColor(rgen.nextColor());
        add(brick);
    }</pre>
<p>
	Der Stein <em>brick</em> muss natürlich eine Instanzvariable sein, sonst funktioniert das nicht.&nbsp; Das Gleiche gilt für <em>rgen</em>.&nbsp; Damit die Steine dann anfangen herunterzufallen, benötigen wir einen <em>GameLoop</em>:</p>
<pre>
    while (true) {
        moveBrick();
        checkForCollision();
        pause(DELAY);
    }</pre>
<p>
	Die Methode <em>moveBrick()</em> bewegt den Stein einfach um eine Steinbreite nach unten.&nbsp; Die Methode <em>checkForCollision()</em> stellt fest ob der Stein weiterfallen darf.&nbsp; Ist der Stein unten angekommen, dann darf er nicht weiterfallen.&nbsp; Der Trick das zu bewerkstelligen ist eigentlich ganz einfach: wir kreiiren einen neuen Stein, und lassen den alten da wo er ist:</p>
<pre>
    private void checkForCollision() {
        if (brick.getY() &gt; getHeight() - brick.getHeight()) {
            createNewBrick();
        }
        ...
    }</pre>
<p>
	Der andere Fall der eintreten kann, ist wenn unterhalb des fallenden Steins ein anderer Stein ist, dann darf er auch nicht weiterfallen. Da müssen wir mit der Methode <em>getElementAt()</em> arbeiten:</p>
<pre>
    int x = brick.getX() + 1;
    int y = brick.getY() + BRICK_SIZE;
    GObject obj = <span style="color:#0000ff;">getElementAt(x, y)</span>;
    if (obj != null) {
        ...
    }
</pre>
<p>
	Diese Methode sagt uns, ob es an der Position x,y ein GObject gibt.&nbsp; Falls nein, dann gibt die Methode &quot;null&quot; zurück.&nbsp; Auch hier kreiiren wir einfach einen neuen Stein.</p>
<p>
	So, jetzt fallen also unsere Stein munter runter.&nbsp; Es fehlt nur noch die Steuerung durch die Tastatur.&nbsp; Die Tastatur hat Tasten, auf Englisch &quot;Keys&quot; und wenn eine Taste gedrückt wird dann kommt es zu einen <em>KeyEvent</em>.&nbsp; Das ist vollkommen analog zu den Maus Events.&nbsp; Deswegen müssen wir also in der setup() Methode noch einen KeyListener hinzufügen:</p>
<pre>
    addKeyListeners();</pre>
<p>
	und die Methode <em>keyPressed()</em> hinzufügen:</p>
<pre>
    public void keyPressed(KeyEvent e) {
        int cc = e.getKeyCode();
        switch (cc) {
        case 37:
            // move left
            brick.move(-BRICK_SIZE, 0);
            break;
        case 39:
            // move right
            brick.move(BRICK_SIZE, 0);
            break;
        }
    }</pre>
<p>
	Über den Keycode erfahren wir welche Taste gedrückt wurde: für die linke Pfeiltaste ist der Keycode die 37, für die rechte die 39.&nbsp; Und damit ist unsere einfache Tetris Version schon fertig.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/pong.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Pong</h2>
<p>
	Pong wurde 1972 von Atari veröffentlich und gilt als Urvater der Videospiele [8].&nbsp; Es ist ein Spiel für zwei Spieler, die versuchen ähnlich wie beim Tischtennis (ping-pong) einen Ball hin und her zu spielen.&nbsp; Zunächst benötigen wir drei Instanzvariablen</p>
<pre>
    private GOval ball;
    private GRect leftPaddle;
    private GRect rightPaddle;</pre>
<p>
	für den Ball und die beiden Paddles. Dann gibt es natürlich wieder einen <em>GameLoop</em>:</p>
<pre>
    while (true) {
        moveBall();
        checkForCollision();
        pause(DELAY);
    }</pre>
<p>
	Die Methode <em>moveBall()</em> bewegt den Ball einfach um einen gewissen Betrag in x und y Richtung.&nbsp;</p>
<p>
	Die Methode <em>checkForCollision()</em> tut zwei Dinge: sie stellt fest ob es eine Kollision mit der Wand gab oder ob es eine Kollision mit einem der Paddles gab.&nbsp; Falls der Ball das Spielfeld nach oben oder unten verlassen möchte, wird er einfach reflektiert, falls er aber nach links oder rechts verschwindet, ist die Runde beendet.&nbsp; Falls der Ball mit den Paddles kollidiert wird er auch einfach reflektiert.&nbsp;</p>
<p>
	Für die Kollisionen mit den Paddles verwenden wir wieder die <em>getElementAt()</em> Methode.&nbsp; Das Reflektieren ist eigentlich auch ganz einfach.&nbsp; Dazu müssen wir aber noch eine Instanzvariable für die Geschwindigkeit einführen:</p>
<pre>
    private int vx = 2;
    private int vy = 3;</pre>
<p>
	Reflektion bedeutet dann einfach:</p>
<pre>
    vy = -vy;</pre>
<p>
	falls der Ball oben oder unten reflektiert werden soll.&nbsp; Natürlich muss die <em>moveBall()</em> Methode diese Variablen verwenden.</p>
<p>
	Die Kontrolle der Paddles soll über die Tastatur erfolgen, also müssen wir wieder einen KeyListener hinzufügen und die Methode <em>keyPressed()</em> hinzufügen:</p>
<pre>
&nbsp;&nbsp; &nbsp;public void keyPressed(KeyEvent e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;char c = e.getKeyChar();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;switch (c) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case &#39;p&#39;: // right paddle up
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rightPaddle.move(0, -PADDLE_VY);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case &#39;l&#39;: // right paddle down
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;...
&nbsp;&nbsp; &nbsp;}
</pre>
<p>
	Wir könnten wieder mit <em>getKeyCode()</em> arbeiten, aber <em>getKeyChar()</em> ist hier viel praktischer.&nbsp; Der erste Spieler kontolliert seinen Paddle über die Tasten &#39;q&#39; und &#39;a&#39;, der zweite Spieler über die Tasten &#39;p&#39; und &#39;l&#39;.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/breakout2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 300px; float: right;" />BrickBreaker</h2>
<p>
	Das erste Breakout-Spiel wurde im April 1976 von Atari vorgestellt.&nbsp; Das Spielprinzip stammt von Nolan Bushnell.&nbsp; Steve Jobs, der damals bei Atari arbeitete, überredete seinen Freund Steve Wozniak (damals bei HP), dieses Spiel zu konstruieren.&nbsp; Steve Jobs bekam für das Spiel Breakout von Nolan Bushnell 5.000 Dollar bezahlt. Er gab seinem Freund Steve Wozniak, die Hälfte, also 350 Dollar [12].</p>
<p>
	Das Spielfeld besteht aus Mauersteinen, einem Ball und einem Schläger.&nbsp; Der Ball bewegt sich durch das Spielfeld und wenn er auf einen Mauerstein trifft, dann verschwindet dieser.&nbsp; Von den Wänden und dem Schläger wird der Ball reflektiert.&nbsp; Außer bei der unteren Wand, also wenn der Ball nicht mit dem Schläger getroffen wird, dann ist das Spiel zu Ende.&nbsp; In unserem Spiel soll der Schläger durch die Maus kontrolliert werden.</p>
<p>
	Als Instanzvariablen benötigen wir wieder den Ball und den Schläger:</p>
<pre>
    private GOval ball;
    private GRect paddle;</pre>
<p>
	Dann folgt die <em>setup()</em> Methode. Dort wollen wir den Ball und den Schläger initialisieren und auch die Mauer malen.</p>
<pre>
    private void setup() {
        createBall();
        createPaddle();
        createBricks();
    }</pre>
<p>
	Beim Malen der Mauer, können wir aber die Methode <em>drawRowOfNBricks(int n)</em> aus dem Projekt Stairs borgen, damit wir es ganz einfach.&nbsp; Evtl wollen wir die Bricks noch verschieden farbig machen, dann sieht das Spiel gleich viel besser aus.</p>
<p>
	Nach dem Setup kommen wir wieder zum <em>GameLoop</em>:</p>
<pre>
    while (true) {
        moveBall();
        checkForCollision();
        pause(DELAY);
    }</pre>
<p>
	Die <em>moveBall()</em> Methode ist identisch zu der in Pong.&nbsp; Auch <em>checkForCollision()</em> ist sehr ähnlich</p>
<pre>
    private void checkForCollision() {
        checkForCollisionWithWall();
        checkForCollisionWithPaddleOrBricks();
    }</pre>
<p>
	Was ein bischen mehr Arbeit benötigt ist die <em>checkForCollisionWithPaddleOrBricks()</em> Methode.&nbsp; Wir verwenden wieder die <em>getElementAt()</em> Methode, schauen nach ob das Objekt nicht null ist.&nbsp; Dann kann es sich nur um den Schläger oder einen Mauerstein handeln, also</p>
<pre>
    GObject obj = getElementAt(x, y);
    if (obj != null) {
        if (obj == paddle) {
            vy = -vy;
        } else {
            // must be brick:
            remove(obj);
            vy = -vy;
        }
    }</pre>
<p>
	Damit wäre der GameLoop erledigt, bleibt noch die Bewegung des Schlägers durch die Maus.&nbsp; Dazu müssen wir im Setup die <em>addMouseListeners()</em> Methode aufrufen und die Methode <em>mouseMoved()</em> implementieren:</p>
<pre>
    public void mouseMoved(MouseEvent e) {
        int x = e.getX();
        paddle.setLocation(x, getHeight() - PADDLE_SEPARATION);
    }</pre>
<p>
	Und das war&#39;s auch schon.</p>
<p>
	.</p>
<hr />
<h1>
	Fragen</h1>
<ol>
	<li>
		Es gibt Methoden mit Rückgabewert und welche ohne.&nbsp; Woran erkennt man, dass eine Methode keinen Rückgabewert hat?<br />
		&nbsp;</li>
	<li>
		Manche Methoden haben Parameter (auch Übergabeparameter genannt).&nbsp; Was sind Parameter?<br />
		&nbsp;</li>
	<li>
		Was haben Parameter und Kilometer gemeinsam?<br />
		&nbsp;</li>
	<li>
		Wir haben mehr als einmal den RandomGenerator &#39;rgen&#39; verwendet.&nbsp; Wie heißt das Kommando um eine Zufallszahl (int) zwischen 1 und 6 zu erzeugen?<br />
		&nbsp;</li>
	<li>
		Wenn man einen primitiven Datentyp an eine Methode als Parameter übergibt, wird dieser im Original oder als Kopie übergeben?<br />
		&nbsp;</li>
	<li>
		Nennen Sie vier Unterklassen (Kinderklassen) der Klasse GObject.<br />
		&nbsp;</li>
	<li>
		Zeichnen Sie Diagramm das grob die Klassenhierarchie der GObjects darstellt.<br />
		&nbsp;</li>
	<li>
		Wir haben den Top-Down Ansatz kennengelernt.&nbsp; Dieser gibt Regeln bzgl der Namen von Methoden, wieviele Zeilen Code eine Methoden haben sollte, etc. Nennen Sie zwei dieser Richtlinien.<br />
		&nbsp;</li>
	<li>
		Analysieren Sie das Spiel &#39;Agar.io&#39; mit Hilfe des Top-Down (Von Oben Nach Unten) Ansatzes. Es geht nur um die Grobstruktur (high-level), nicht um detaillierten Code.<br />
		&nbsp;</li>
	<li>
		Die Methode addThirteen() im folgenden Code funktioniert nicht wie erwartet. Was ist das Problem? Wie würden Sie es lösen?<br />
		<br />
		<strong><span style="font-family:courier new,courier,monospace;">private void addThirteen(int x ) {<br />
		&nbsp;&nbsp;&nbsp; x += 12;<br />
		}<br />
		public void run() {<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp;&nbsp; </span>int x = 4;<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp;&nbsp; </span>addThirteen( x );<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp;&nbsp; </span>println( &quot;x = &quot; + x );<br />
		}</span></strong><br />
		&nbsp;</li>
	<li>
		Das Arcade-Spiel &#39;RandomCircles&#39; war ein absoluter Hit in den späten 80er Jahren.&nbsp; Es handelt sich dabei um ein Spiel, das an der Stelle an der die Benutzerin mit der Maus klickt einen bunten Kreis zeichnet.&nbsp; Es wäre etwas zu viel verlangt die Vollversion des Spiels zu implementieren, aber es ist relativ einfach, den Code zu schreiben, der<br />
		1)&nbsp; einen farbigen Kreis auf dem Bildschirm zeichnet und<br />
		2)&nbsp; den Kreis dort zeichnet, wo die Benutzerin mit der Maus geklickt hat.<br />
		<br />
		In einem ersten Schritt erstellen Sie eine Klasse namens GCircle, die GOval erweitert (extends) und ein Kreis mit zufälliger Größe und Farbe zeichnet.<br />
		<br />
		In einem zweiten Schritt, schreiben Sie eine GraphicsProgram, das auf Mausklicks hört und einen Kreis an die Stelle zeichnet, an die die Benutzerin mit der Maus geklickt hat.<br />
		<br />
		Evtl ist die folgende Information hilfreich:<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp;&nbsp; private RandomGenerator rgen = RandomGenerator.getInstance();</span><br />
		Der RandomGenerator hat u.a. folgende Methoden:<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp;&nbsp; int nextInt( int low, int high )<br />
		&nbsp;&nbsp;&nbsp; Color nextColor()</span><br />
		&nbsp;</li>
</ol>
<p>
	.</p>
<hr />
<h1>
	Referenzen</h1>
<p>
	Die Referenzen relevant für dieses Kapitel sind die gleichen wie in Kapitel 2.&nbsp; Weitere Details zur ACM Grafik Bibliothek kann man auf den Seiten der ACM Java Task Force [1] finden.&nbsp; Viele weitere Beispiele findet man im Tutorial [2], dem Buch von Eric Roberts [3] und der Stanford Vorlesung &#39;Programming Methodologies&#39; [4] oder sind von ihnen inspiriert.</p>
<p>
	[1] ACM Java Task Force, <a href="http://cs.stanford.edu/people/eroberts/jtf/">cs.stanford.edu/people/eroberts/jtf/</a></p>
<p>
	[2] ACM Java Task ForceTutorial , <a href="http://cs.stanford.edu/people/eroberts/jtf/tutorial/index.html">cs.stanford.edu/people/eroberts/jtf/tutorial/index.html</a></p>
<p>
	[3] The Art and Science of Java, von Eric Roberts, Addison-Wesley, 2008</p>
<p>
	[4] CS106A - Programming Methodology - Stanford University, <a href="https://see.stanford.edu/Course/CS106A">https://see.stanford.edu/Course/CS106A</a></p>
<p>
	[5] HSL and HSV, <a href="https://en.wikipedia.org/w/index.php?title=HSL_and_HSV&amp;oldid=694879918">https://en.wikipedia.org/w/index.php?title=HSL_and_HSV&amp;oldid=694879918</a> (last visited Mar. 3, 2016).</p>
<p>
	[6] Moiré-Effekt, <a href="https://de.wikipedia.org/wiki/Moiré-Effekt">https://de.wikipedia.org/wiki/Moiré-Effekt</a></p>
<p>
	[7] Sinus und Kosinus, <a href="https://de.wikipedia.org/wiki/Sinus_und_Kosinus">https://de.wikipedia.org/wiki/Sinus_und_Kosinus</a></p>
<p>
	[8] Pong, <a href="https://de.wikipedia.org/wiki/Pong">https://de.wikipedia.org/wiki/Pong</a></p>
<p>
	[9] Tic-Tac-Toe, <a href="https://de.wikipedia.org/wiki/Tic-Tac-Toe">https://de.wikipedia.org/wiki/Tic-Tac-Toe</a></p>
<p>
	[10] Agar.io, <a href="https://de.wikipedia.org/wiki/Agar.io">https://de.wikipedia.org/wiki/Agar.io</a></p>
<p>
	[11] Tetris, <a href="https://de.wikipedia.org/wiki/Tetris">https://de.wikipedia.org/wiki/Tetris</a></p>
<p>
	[12] Breakout, <a href="https://de.wikipedia.org/wiki/Breakout_(Computerspiel)">https://de.wikipedia.org/wiki/Breakout_(Computerspiel)</a></p>
<p>
	.</p>
<p class="footer">
Copyright &copy; 2016-2021 <a href="http://www.lano.de">Ralph P. Lano</a>.  All rights reserved.
</p>
</div>
</center>
</div>
</body>
</html>