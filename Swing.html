<!DOCTYPE html><html lang="de"><head>
  <title>Variationen zum Thema: Java</title>
  <meta name="title" content="Variationen zum Thema: Java">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta charset="UTF-8">
  <meta name="description" content="Introduction to Java Programming">
  <meta name="keywords" content="java,introduction">
  <meta name="author" content="Ralph P. Lano">
  <meta name="robots" content="index,follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="book.css">
</head>
<body><center>
<div id="wrap">
	<ul class="sidenav">
	  <p><a href="index.html">Variationen zum Thema</a><a href="index.html">Java</a></p>
	  <li><a href="Karel.html">Karel</a></li>
	  <li><a href="Graphics.html">Graphics</a></li>
	  <li><a href="Console.html">Console</a></li>
	  <li><a href="Agrar.html">Agrar</a></li>
	  <li><a href="MindReader.html">MindReader</a></li>
	  <li><a href="Swing.html">Swing</a></li>
	  <li><a href="Asteroids.html">Asteroids</a></li>
	  <li><a href="Stocks.html">Stocks</a></li>
	</ul>
<div class="content"><p>
	<img alt="" src="images/a6a5703b-cf7a-4778-aaa4-c635989a9ec5.png" style="display: block; margin-left: auto;  margin-right: auto; width: 225px; height: 204px;" /></p>
<h1>
	Swing</h1>
<p>
	Programme mit grafischer Benutzeroberfläche (GUI) sind das Thema in diesem Kapitel. Ähnlich wie bei Grafikprogrammen gibt es vorgefertigte Komponenten mit denen wir dann die verschiedensten kleinen und großen Programme bauen.&nbsp; Das ist ein bischen wie Lego.&nbsp; Zusätzlich werden wir hier noch ein wenig mehr über Instanzvariablen erfahren.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/377f7211-da52-4eb6-8c44-0ac3a14e6b81.png" style="width: 292px; height: 261px; float: right;" />Grafische Benutzeroberfläche</h2>
<p>
	Die meisten Programme mit denen wir täglich zu tun haben, sind Programme mit einer grafischen Benutzeroberfläche, oder englisch <em>graphical user interface</em> (GUI oder UI).&nbsp; GUIs bestehen aus grafischen Elementen, die wir auch Widgets oder Interaktoren nennen, weil wir mit ihnen interagieren können.&nbsp; Bekannte Beispiele sind:</p>
<ul>
	<li>
		Labels</li>
	<li>
		Buttons</li>
	<li>
		Textfields</li>
	<li>
		Checkboxes</li>
	<li>
		Radiobuttons</li>
	<li>
		Comboboxes</li>
</ul>
<p>
	Im Folgenden werden wir einen nach dem anderen ausprobieren.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/DateAndTime.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JLabel</h2>
<p>
	Wir beginnen wieder ganz einfach, mit dem JLabel.&nbsp; Es gibt praktisch keinen Unterschied zum GLabel.&nbsp; Er wird verwendet um Text in GUI Programmen darzustellen:</p>
<pre>
public class DateAndTime extends <span style="color:#0000ff;">Program</span> {

&nbsp;&nbsp; &nbsp;public void <span style="color:#0000ff;">init</span>() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Date dt = new Date();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JLabel fritz = new JLabel(dt.toLocaleString());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fritz.setFont( new Font(&quot;SansSerif&quot;, Font.PLAIN, 20) );
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add( fritz, NORTH );
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Zu unseren bisherigen Programmen sehen wir zwei Unterschiede: wir schreiben jetzt &quot;<em>extends Program</em>&quot; anstelle von GraphicsProgram oder ConsoleProgram.&nbsp; Und wir verwenden die <em>init()</em> Methode anstatt der <em>run()</em> Methode.&nbsp; Das ist zwar nicht zwingend notwendig, aber guter Stil.&nbsp; Desweiteren sehen wir zum ersten Mal die Klasse <em>Date</em>.&nbsp; Die ist ganz praktisch wenn man Datum oder Uhrzeit benötigt.&nbsp; Und wir sehen die Klasse <em>Font</em>, mit der man den Font eines JLabels ändern kann. &nbsp;</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/FirstButton.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JButton</h2>
<p>
	Der JLabel ist nicht besonders interaktiv, und verdient den Namen eigentlich gar nicht.&nbsp; Anders ist das allerdings beim <em>JButton</em>, denn auf den kann man mit der Maus klicken.&nbsp; Wir fangen ganz einfach an:</p>
<pre>
public class FirstButton extends ConsoleProgram {

&nbsp;&nbsp; &nbsp;public void init() {&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JButton btn = new JButton(&quot;OK&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add( btn, SOUTH );
&nbsp;&nbsp; &nbsp;}
}
</pre>
<p>
	Wir legen einen neuen JButton an, auf dem &quot;OK&quot; stehen soll.&nbsp; Den fügen wir dann im Süden hinzu.&nbsp; Unser FirstButton Programm ist wieder ein ConsoleProgram, das ist aber o.k.&nbsp; Wenn wir das Programm starten, können wir zwar auf den Knopf drücken, es passiert aber nichts.</p>
<p>
	Damit der Knopf richtig funktioniert, also interaktiv wird, müssen wir zwei Dinge tun:</p>
<ol>
	<li>
		wir müssen am Ende von init() die Method <em>addActionListeners()</em> aufrufen und</li>
	<li>
		wir müssen eine Methode namens <em>public void actionPerformed()</em> implementieren.</li>
</ol>
<p>
	Der erste Schritt sagt dem Programm, dass wir informiert werden möchten wenn irgendein Knopf gedrückt wird.&nbsp; Und wie werden wir informiert?&nbsp; Man ruft uns an, allerdings nicht auf dem Telefon, sondern mit der Methode <em>actionPerformed()</em>.&nbsp; D.h., jedes Mal wenn jemand auf den Knopf drückt, dann wird diese Methode aufgerufen.&nbsp; Schauen wir uns das im Ganzen noch mal an:</p>
<pre>
public class FirstButton extends ConsoleProgram {

&nbsp;&nbsp; &nbsp;public void init() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JButton btn = new JButton(&quot;OK&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add( btn, SOUTH );
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">addActionListeners()</span>;
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;public void <span style="color:#0000ff;">actionPerformed</span>( ActionEvent e ) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot;hi:&quot; + e.getActionCommand());
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Jetzt wird in dem Konsolenteil unseres Programms jedes Mal &quot;hi:&quot; mit dem Namen des Knopfes ausgegeben, wenn wir mit der Maus auf den Knopf drücken.&nbsp;</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/3d9087be-7b2e-4d4e-af76-a1127aa0645b.png" style="margin-left: 10px; margin-right: 10px; width: 387px; height: 178px; float: right;" />Regionen</h2>
<p>
	In den zwei Beispielen oben, haben wir bereits zwei Regionen kennengelernt, insgesamt gibt es fünf: EAST, WEST, SOUTH, NORTH, und CENTER.&nbsp; Wir können unsere Widgets in jede dieser Regionen einfügen.&nbsp;</p>
<p>
	Eines was ein <em>ConsoleProgram</em> von einem <em>GraphicsProgram</em> und wiederum von einem <em>Program</em> unterscheidet, ist was in der CENTER Region ist.&nbsp; Beim <em>Program</em> ist da gar nichts.&nbsp; Beim <em>GraphicsProgram</em> ist da ein GCanvas eingefügt, und beim <em>ConsoleProgram</em> eine TextArea.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Login2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JTextField</h2>
<p>
	Mittels des JTextField Widgets können wir Text und auch Zahlen einlesen.&nbsp; Im folgenden Beispiel möchten wir, dass sich die Nutzer mit ihrem Namen anmelden.</p>
<pre>
public class Login extends ConsoleProgram {
&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">private JTextField tf;</span>

&nbsp;&nbsp; &nbsp;public void init() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JLabel lbl = new JLabel(&quot;Name: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(lbl, SOUTH);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">tf</span> = new JTextField(10);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(<span style="color:#0000ff;">tf</span>, SOUTH);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JButton btn = new JButton(&quot;Login&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add( btn, SOUTH );
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;addActionListeners();
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void actionPerformed(ActionEvent e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot;Name: &quot; + <span style="color:#0000ff;">tf</span>.getText());
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Wir legen einen JLabel, ein JTextField und einen JButton an.&nbsp; Im Konstruktor des JTextField sagen wir wie breit das Feld sein soll.&nbsp; Wichtig ist noch, dass das JTextField <em>tf</em> eine Instanzvariable ist.&nbsp; Wäre es nämlich eine lokale Variable, dann könnten wir nicht in der <em>actionPerformed()</em> Methode darauf zugreifen.</p>
<p>
	Ein kleine Verbesserung des Codes bringt die folgende Zeile</p>
<pre>
        tf.addActionListener(this);</pre>
<p>
	die wir direkt vor dem add(tf) einfügen können.&nbsp; Diese Zeile bewirkt nämlich, dass es auch genügt einfach die &quot;Enter&quot; Taste zu drücken um sich einzuloggen.</p>
<p>
	.</p>
<h2>
	Instanzvariablen</h2>
<p>
	Wir haben zwar schon im letzten Kapitel kurz mal mit Instanzvariablen zu tun gehabt, aber gerade im obigen Beispiel haben wir gesehen wofür sie eigentlich gut sind:&nbsp; sie erlauben es zwischen verschiedenen Methoden Information auszutauschen.&nbsp; Bisher konnten wir dafür lediglich Parameter und Rückgabewerte verwenden.</p>
<p>
	Ein anderer Grund warum Instanzvariablen ganz praktisch sein können, hat damit zu tun, dass alle lokalen Variablen wieder gelöscht werden, wenn eine Methode verlassen wird.&nbsp; Also z.B. in der Methode <em>rollTheDie()</em>,</p>
<pre>
&nbsp;&nbsp; &nbsp;private void rollTheDie() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;RandomGenerator rgen = new RandomGenerator();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int dieRoll = rgen.nextInt(1,6);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(dieRoll);
&nbsp;&nbsp; &nbsp;}
</pre>
<p>
	wird bei jedem Aufruf ein neue Instanz des RandomGenerator erzeugt und dann beim Verlassen wieder gelöscht.&nbsp; Beides braucht Zeit.&nbsp; Wenn wir aber den RandomGenerator als Instanzvariable anlegen,</p>
<pre>
public class InstanceVariables extends ConsoleProgram {
&nbsp;&nbsp; &nbsp;private RandomGenerator rgen = new RandomGenerator();
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;private void rollTheDie() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int dieRoll = rgen.nextInt(1,6);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(dieRoll);
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	dann müssen wir ihn nur einmal anlegen, und zusätzlich können wir ihn auch in anderen Methoden verwenden.&nbsp; Das ist viel resourcenschonender.</p>
<p>
	.</p>
<h2>
	Instanzvariablen vs. Lokale Variablen</h2>
<p>
	Es gibt also zwei Arten von Variablem: Instanzvariablen und lokale Variablen.&nbsp; Für Instanzvariablen gilt, dass sie in der Klasse deklariert werden und nicht in einer Methode, dass sie in der gesamten Klasse sichtbar sind, also von allen Methoden einer Klasse auf sie zugegriffen werden kann und dass sie solange leben wie das Objekt existiert.</p>
<p>
	Für lokale Variablen gilt umgekehrt, dass sie innerhalb einer Methode deklariert werden, dass nur innerhalb dieser Methode auf sie zugegriffen werden kann und dass sie beim Verlassen der Methode wieder gelöscht werden.</p>
<p>
	Nun stellt sich die Frage, wann verwende ich welche?&nbsp; Die Antwort ist in den meisten Fällen relativ einfach:</p>
<ul>
	<li>
		wenn es sich um eine Berechnung handelt, die lokal in einer Methode ausgeführt werden kann, dann verwendet man lokale Variablen, z.B. die Umwandlung von Grad nach Fahrenheit ist eine lokale Berechnung</li>
	<li>
		wenn eine Information in mehreren Methoden verwendet wird, dann sollte man eine Instanzvariable nehmen</li>
	<li>
		wenn es sich um den internen Zustand eines Objektes handelt, dann sollte man eine Instanzvariable verwenden.&nbsp; Z.B. bei der Klasse Student waren der Name, die Id und die Credits interne Zustände.</li>
</ul>
<p>
	<strong>SEP: Wenn möglich sollte man lokalen Variablen verwenden.</strong></p>
<p>
	.</p>
<h2>
	Übung: OKCancel</h2>
<p>
	Als kleine Übung fügen wir noch einen <em>Cancel</em> Knopf zu unserem Programm hinzu.&nbsp; Wie können wir jetzt unterscheiden welcher der beiden Knöpfe denn gedrückt wurde?&nbsp; Hier ist manchmal sinnvoller die <em>getSource()</em> Methode des ActionEvents zu verwenden,</p>
<pre>
&nbsp;&nbsp;&nbsp; public void actionPerformed( ActionEvent e ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( e.getSource() == btnOK ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
</pre>
<p>
	um zwischen mehreren Knöpfen oder Widgets im Allgemeinen zu unterscheiden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Pizza.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JCheckBox</h2>
<p>
	Als nächstes Widget widmen wir uns den Checkboxes:&nbsp; Diese verwenden wir wenn wir mehrere Auswahlmöglichkeiten haben.</p>
<pre>
&nbsp;&nbsp;&nbsp; public void init() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JLabel lbl = new JLabel(&quot;Select your toppings:&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(lbl, NORTH);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JCheckBox topping1 = new JCheckBox(&quot;Tomatoes&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(topping1, CENTER);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JCheckBox topping2 = new JCheckBox(&quot;Bacon&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(topping2, CENTER);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JCheckBox topping3 = new JCheckBox(&quot;Onions&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(topping3, CENTER);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	In dem Pizza Beispiel soll es möglich sein alle möglichen Kombinationen von Toppings auszuwählen.&nbsp; Das kann man am besten mit Checkboxes erreichen.&nbsp; Um festzustellen welche Toppings ausgewählt wurden, gibt es die Methode <em>isSelected()</em>:</p>
<pre>
&nbsp;   boolean b = topping1.isSelected();</pre>
<p>
	Das müssten wir natürlich für alle drei Toppings machen.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Exam.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JRadioButton</h2>
<p>
	Radiobuttons werden verwendet wenn es darum geht Entscheidungen zu treffen.&nbsp; Betrachten wir das folgende Beispiel:</p>
<pre>
&nbsp;&nbsp;&nbsp; public void init() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JLabel lbl = new JLabel(&quot;Correct:&nbsp; 1 + 1 = 2 ?&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(lbl, NORTH);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JRadioButton yes = new JRadioButton(&quot;Yes&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;yes.<span style="color:#0000ff;">setSelected</span>(true);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(yes, SOUTH);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JRadioButton no = new JRadioButton(&quot;No&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(no, SOUTH);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ButtonGroup happyGrp = new ButtonGroup();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;happyGrp.add(yes);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;happyGrp.add(no);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Wir haben hier zwei Radiobuttons, wobei der &quot;yes&quot; Button vorselektiert ist.&nbsp; Damit das Programm weiß welche Buttons zusammengehören, fügt man zusammengehörtige Buttons in eine ButtonGroup zusammen.&nbsp; Das führt dann dazu, dass immer nur einer der Buttons ausgewählt sein kann.&nbsp; Will man wissen welchen Button der Nutzer gewählt hat, kann man das mittels:</p>
<pre>
&nbsp;   boolean b = yes.isSelected();</pre>
<p>
	feststellen.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/FavoriteColor.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />JComboBox</h2>
<p>
	Als Beispiel für die JComboBox schauen wir uns das Beispiel FavoriteColor an.&nbsp; Es geht darum eine Farbe aus einer Liste auszuwählen:</p>
<pre>
public class FavoriteColor extends ConsoleProgram {
&nbsp;&nbsp; &nbsp;private <span style="color:#0000ff;">JComboBox</span> colorPicker;

&nbsp;&nbsp; &nbsp;public void init() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;colorPicker = new JComboBox();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;colorPicker.addItem(&quot;Red&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;colorPicker.addItem(&quot;White&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;colorPicker.addItem(&quot;Blue&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(colorPicker, SOUTH);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;addActionListeners();
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void actionPerformed(ActionEvent e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot;Color:&quot; + <span style="color:#0000ff;">colorPicker.getSelectedItem()</span>);
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	In der init() Methode initialisieren wir den <em>colorPicker</em> mit den voreingestellten Farben.&nbsp; Um festzustellen welche Farbe der Benutzer ausgewählt hat, gibt es die <em>getSelectedItem()</em> Methode.&nbsp; Damit wir aber auf diese in der <em>actionPerformed()</em> Methode zugreifen können, muss <em>colorPicker</em> eine Instanzvariable sein.</p>
<p>
	Anmerkung: wenn wir ganz genau das Verhalten der JComboBox beobachten, werden wir feststellen, dass sie ein paar klein Quirks hat.&nbsp; Kann man nix machen.</p>
<p>
	.</p>
<h2>
	Swing Interactor Hierarchie</h2>
<p>
	Ähnlich wie es bei den ACM Grafikklassen eine Hierarchie gibt, gibt es die auch bei den Swing Interaktor Klassen.&nbsp; Die wichtigsten sind in dem nebenstehenden Diagramm zusammengefasst, es gibt aber noch weitaus mehr.</p>
<p>
	<img alt="" src="http://127.0.0.1:8000../images/SwingClassDiagram.jpg" style="margin-left: 10px; margin-right: 10px; width: 673px; height: 405px;" /></p>
<p>
	.</p>
<h2>
	<img alt="" src="images/40c49c0e-a278-44cc-963a-fb7a816b117f.png" style="width: 246px; height: 251px; float: right;" />Layout</h2>
<p>
	Wir haben bereits die Regionen EAST, WEST, SOUTH, NORTH, und CENTER kennengelernt. Diese sind eine Besonderheit des BorderLayouts.&nbsp; Es gibt neben dem BorderLayout noch einige andere.&nbsp; Es geht darum wie man mehrere Widgets auf dem Bildschirm &quot;auslegt&quot; (layout).&nbsp; Zu den wichtigeren Layouts zählen die Folgenden:&nbsp;</p>
<ul>
	<li>
		<strong>BorderLayout:</strong> hier gibt es fünf Regionen und Widgets müssen explizit einer Region zugewiesen werden</li>
	<li>
		<strong>FlowLayout:</strong>&nbsp; ist das einfachste Layout, Widgets werden einfach von links nach rechts nebeneinander ausgelegt</li>
	<li>
		<strong>GridLayout:</strong>&nbsp; der verfügbare Platz wird in gleich große Flächen aufgeteilt, z.B. 3 mal 2</li>
</ul>
<p>
	Sehen wir uns ein paar Beispiele dazu an.&nbsp; Um den BorderLayout zu verwenden würden wir folgenden Code verwenden:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setLayout(new BorderLayout());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;EAST&quot;), EAST);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;WEST&quot;), WEST);
        ...
</pre>
<p>
	Für den FlowLayout sieht das dann so aus:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setLayout(new FlowLayout());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;0&quot;));
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;1&quot;));
        ...</pre>
<p>
	und für den GridLayout so:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setLayout(new GridLayout(2, 3));
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;0&quot;));
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(new JButton(&quot;1&quot;));
        ...</pre>
<p>
	Grafisch sieht das Ganze dann so aus:</p>
<table align="center" border="0" cellpadding="10" cellspacing="10" style="width: 100%;">
	<tbody>
		<tr>
			<td style="text-align: center; vertical-align: middle;">
				<img alt="" src="images/BorderLayout.png" style="width: 200px; height: 100px;" /></td>
			<td style="text-align: center; vertical-align: middle;">
				<img alt="" src="images/FlowLayout.png" style="width: 200px; height: 100px;" /></td>
			<td style="text-align: center; vertical-align: middle;">
				<img alt="" src="images/GridLayout.png" style="width: 200px; height: 100px;" /></td>
		</tr>
	</tbody>
</table>
<p>
	.</p>
<h2>
	JPanel</h2>
<p>
	Was die GCompound für GraphicsProgramme war ist das JPanel für Swing: es erlaubt es uns mehrere Widgets zu einem neuen Widget zusammenzufassen.&nbsp; Details zur JPanel Klasse sehen wir weiter unten im Projekt &quot;Quiz&quot;.</p>
<p>
	.</p>
<hr />
<h1>
	Review</h1>
<p>
	Glückwunsch!&nbsp; Wie wir gleich sehen werden, haben wir jetzt das Rüstzeug um fast beliebige grafische Benutzeroberflächen (UIs) zu basteln.&nbsp; Wir wissen jetzt wie man mit</p>
<ul>
	<li>
		Labels</li>
	<li>
		Buttons</li>
	<li>
		Textfields</li>
	<li>
		Checkboxes</li>
	<li>
		Radiobuttons</li>
	<li>
		und Comboboxes</li>
</ul>
<p>
	arbeitet.&nbsp; Außerdem haben wir etwas über verschiedene Layouts erfahren, und kurz die Bekanntschaft des JPanel gemacht.&nbsp;</p>
<p>
	Mindestens genauso wichtig war aber die Vertiefung zu Instanzvariablen.&nbsp; Es sollte jetzt etwas klarer sein, was diese von lokalen Variablen unterscheidet, und wann man welche der beiden verwendet.</p>
<p>
	.</p>
<hr />
<h1>
	Projekte</h1>
<p>
	In den Projekten in diesem Kapitel werden wir viele UIs erstellen.&nbsp; Manche brauchen wir später noch, um sie mit Leben zu füllen.&nbsp; Es gibt wieder viel zu tun.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Clock.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Clock</h2>
<p>
	Wir wollen eine kleine Uhr schreiben.&nbsp; Dazu verwenden wir die <em>Date</em> Klasse und deren Methoden <em>getHours()</em>, <em>getMinutes()</em> und <em>getSeconds()</em>.&nbsp; Für die Anzeige selbst verwenden wir einen JLabel.&nbsp; Und natürlich sollte der Text des JLabels sich einmal pro Sekunde (besser zweimal) verändern.&nbsp; Dazu kann man die <em>setText()</em> Methode des JLabels verwenden.&nbsp;</p>
<p>
	Unter Umständen macht es Sinn eine Methode <em>padWithZeros()</em> zu schreiben, die sicher stellt, dass anstelle von &quot;6&quot; Minuten &quot;06&quot; Minuten angezeigt werden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/wordGuess.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 80px; float: right;" />WordGuess</h2>
<p>
	WordGuess ist sozusagen eine grafische Version von Hangman aus dem letzten Kapitel.&nbsp; Es geht darum ein Wort zu erraten indem man Buchstaben eingibt.</p>
<p>
	Man beginnt damit, dass man ein zufälliges Wort mit der Methode <em>pickRandomWord()</em> auswählt.&nbsp; Dieses Wort sollte man als Instanzvariable <em>wordToGuess</em> speichern.&nbsp; Dann sollte man daraus ein Wort mit lauter &quot;-&quot; Strichen machen, <em>wordShown</em>, auch eine Instanzvariable.&nbsp; Dann kreiirt man einen JLabel und fügt diesen im Norden dazu:</p>
<pre>
    wordLbl = new JLabel(wordShown);
    add(wordLbl, NORTH);
    wordLbl.<span style="color:#0000ff;">addKeyListener(this)</span>;
    wordLbl.requestFocus();</pre>
<p>
	Interessant ist die Art und Weise wie wir hier den KeyListener hinzufügen: zunächst einmal ist er Teil des Labels, und zum zweiten übergeben wir &quot;this&quot; als Parameter.&nbsp; Momentan brauchen wir das noch nicht zu verstehen, aber effektiv führt es dazu, dass wir auf KeyEvents hören können.&nbsp; Die <em>requestFocus()</em> Methode ist nötig, damit der KeyListener auch funktioniert.</p>
<p>
	Was bleibt ist die Methode <em>keyTyped(KeyEvent e)</em> zu implementieren.&nbsp; Diese wird aufgerufen wenn der Nutzer eine Taste drückt, was dann passieren soll ist ähnlich wie bei Hangman, wir prüfen ob der Buchstabe im <em>wordToGuess</em> vorhanden ist, und updaten den Label falls er ist.&nbsp; Natürlich macht es auch noch Sinn zu zählen wieviel Versuche benötigt wurden um das Wort zu erraten.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/StopWatch.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />StopWatch</h2>
<p>
	Eine Stoppuhr muss eine höhere Genauigkeit haben als die Klasse <em>Date</em> liefert.&nbsp; Dafür gibt es die Systemmethode</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long time = System.currentTimeMillis();</pre>
<p>
	welche uns die Millisekunden liefert, die seit 0 Uhr des 1.1.1970 verstrichen sind.&nbsp; Wenn wir eine Zeit die in Millisekunden gegeben ist durch 1000 teilen erhalten wir die Sekunden, wenn wir Modulo 1000 nehmen erhalten wir die Millisekunden.</p>
<p>
	Die Anzeige soll animiert sein, deswegen macht es Sinn das Ganze in einen GameLoop zu stecken.&nbsp; Ausserdem macht es Sinn einen Delay von 20ms zu haben, sonst kommt die Anzeige nicht nach mit dem Anzeigen.&nbsp; Und wir sollten zwei Knöpfe mit einbauen, einen zum Starten und einen zum Pausieren.</p>
<p>
	Den primitiven Datentyp <em>long</em> haben wir bisher noch nicht gesehen.&nbsp;&nbsp; Er verhält sich wie ein <em>int</em>, ist also für Ganzzahlen gedacht.&nbsp; Der einzige Unterschied, während ints 32 Bit sind, sind die longs 64 Bit, d.h. sie eignen sich für größere Zahlen (32-bit Zahlen sind zwischen -2^31 und +2^31 und 64-bit Zahlen sind zwischen -2^63 und +2^63).</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/CountDown.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />CountDown</h2>
<p>
	Ganz ähnlich wie die Stoppuhr funktioniert der CountDown.&nbsp; Anstelle eines JLabels verwenden wir aber ein JTextField.&nbsp; Der Vorteil ist, dass man dieses editieren kann, d.h. man kann die Zahl einstellen von der man aus rückwärts zählen möchte.&nbsp; Sobald der Nutzer dann auf den &quot;Start&quot; Knopf drückt, soll der Countdown beginnen.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Ticker.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 51px;" />Ticker</h2>
<p>
	Eine Laufschrift (Werbe-Ticker) ist relativ einfach zu implementieren.&nbsp; Wir verwenden dazu einen JLabel.&nbsp; In einem GameLoop bewegen wir in dann alle 50 Millisekunden um 5 Pixel nach links mittels</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl.move(-5, 0);</pre>
<p>
	.</p>
<h2>
	<img alt="" src="images/AlarmClock.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />AlarmClock</h2>
<p>
	Eine Alarmuhr zu schreiben, die mit einem Stunden:Minuten:Sekunden Format arbeitet ist überraschen kompliziert.&nbsp; Allerdings wenn man die Methoden für die Konvertierung vom Stunden:Minuten:Sekunden nach Sekunden (<em>convertTimeInSeconds()</em>) und von Sekunden nach Stunden:Minuten:Sekunden (<em>convertSecondsInTime()</em>) schon hat, dann ist es gar nicht so schwer, und eigentlich identisch mit dem CountDown Projekt.</p>
<p>
	Für das Programm verwenden wir einen großen JLabel, den wir im Norden platzieren.&nbsp; Außerdem gibt es ein JTextField im Süden für die Eingabe der Alarmzeit im Stunden:Minuten:Sekunden Format.&nbsp; Und es gibt einen JButton über den der Alarm gestartet wird.&nbsp;</p>
<p>
	Es macht Sinn zwei Instanzvariablen zu verwenden:</p>
<pre>
    private long alarmTime = -1;
    private boolean alarmStarted = false;</pre>
<p>
	Die erste ist einfach die Zeit in Sekunden, und die zweite wird verwendet um dem GameLoop mitzuteilen, dass etwas zu tun ist:</p>
<pre>
    while (true) {
        if (alarmStarted) {
            // display remaining time
            ...
        }
        pause(DELAY);
    }</pre>
<p>
	Wenn der JButton gedrückt wird, dann wir zum einen alarmTime auf die Sekunden gesetzt, und alarmStarted wird auf <em>true</em> gesetzt, damit der GameLoop weiß, dass er jetzt was anzeigen soll.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Editor.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />Editor</h2>
<p>
	Als nächstes steht ein Texteditor auf unserem Plan.&nbsp; Dieser besteht zum Einen aus einem JTextField für den Dateinamen und zwei JButtons, einer zum Laden, der andere zum Speichern von Dateien.&nbsp; Diese drei Widgets platzieren wir im Norden, also dem unteren Teil.&nbsp;</p>
<p>
	In den Mittelteil, CENTER, kommt eine JTextArea:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;display = new JTextArea();
        display.setFont(new Font(&quot;Courier&quot;, Font.BOLD, 18));
        add(display, CENTER);</pre>
<p>
	Eine JTextArea ist wie ein JTextField, nur dass man da auch Mehrzeilentext eingeben kann.</p>
<p>
	Wie das Laden und Speichern von Dateien geht, lernen wir im nächsten Kapitel.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/Quiz.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Quiz</h2>
<p>
	Wir wollen eine UI für ein MultipleChoice Quiz schreiben.&nbsp; Diese besteht aus einer Frage, also einen JLabel, den wir im oberen Bereich (NORTH) platzieren.&nbsp; Dann folgen die möglichen Antworten.&nbsp; Dies sind natürlich Checkboxes.&nbsp; Da sie zusammen gehören, gruppieren wir sie in eine Buttongroup.&nbsp; Die Checkboxes kommen in den mittleren Bereich (CENTER).&nbsp; Schließlich, wollen wir auch noch zwei Navigations Knöpfe hinzufügen, im unteren Bereich.&nbsp; Das Programm soll keine weitere Funktion haben, die kommt im übernächsten Kapitel.</p>
<p>
	Dieses Programm ist ein schönes Beispiel wie man JPanels einsetzen kann.&nbsp; Multiplechoice Fragen bestehen nicht immer aus drei Antworten.&nbsp; Manchmal sind es weniger, manchmal mehr.&nbsp; Also macht es Sinn, die Fragen zusammenzufassen und in ein JPanel einzufügen.&nbsp;</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; JPanel answersPnl = new JPanel();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; answersPnl.setLayout(new GridLayout(3, 1));
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;JRadioButton btn1 = new JRadioButton(answer1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;answersPnl.add(btn1);
        ...
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(answersPnl, CENTER);</pre>
<p>
	Dieses JPanel fügen wir dann in den mittleren Bereich.</p>
<p>
	.</p>
<h2>
	<img alt="" src="images/DrawingEditor2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />DrawingEditor&nbsp;</h2>
<p>
	Im übernächsten Kapitel wollen wir einen DrawingEditor schreiben.&nbsp; Bis dahin können wir schon einmal etwas Vorarbeit leisten.&nbsp; Die Idee ist, dass wir zwischen den Formen Rechteck und Kreis mittels zweier Radiobuttons auswählen können.&nbsp; Zusätzlich wollen wir einstellen können ob die Formen ausgefüllt sind oder nicht, das geht am besten mit einer Checkbox.&nbsp; Und schließlich, möchten wir noch die Farbe der Formen bestimmen können.</p>
<p>
	.</p>
<hr />
<h1>
	Challenges</h1>
<p>
	.</p>
<h2>
	<img alt="" src="images/Calculator.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />Calculator</h2>
<p>
	Unser nächstes Projekt ist ein kleiner Taschenrechner.&nbsp; Dieser besteht aus einem JTextField (<em>display</em>) und 16 JButtons.&nbsp; Am besten wir platzieren das JTextField im Norden, und die JButtons in ein 4x4 GridLayout.</p>
<p>
	Bei der Programmierung der Logik des Rechners müssen wir etwas überlegen.&nbsp; Zunächst macht es Sinn zwei Instanzvariablen einzuführen:</p>
<pre>
    private double operand1 = 0;
    private char operation = &#39;+&#39;;</pre>
<p>
	Wenn wir z.B. &quot;6 - 2&quot; mit einem Taschenrechner ausrechnen, dann geben wir ja zuerst die Zahl &quot;6&quot; ein, dann das &quot;-&quot; und danach die &quot;2&quot;.&nbsp; Wir müssen uns also zwischendurch sowohl die &quot;6&quot; als auch das &quot;-&quot; merken, deswegen die beiden Instanzvariablen.&nbsp;</p>
<p>
	In der <em>actionPerformed()</em> Methode müssen wir also unterscheiden zwischen dem &quot;=&quot; Zeichen, den Operatoren &quot;+&quot;, &quot;-&quot;,&quot;*&quot; und&nbsp; &quot;/&quot;, und den Ziffern.&nbsp;</p>
<p>
	Wenn Ziffern eingegeben werden, dann fügen wir die einfach zum display hinzu:</p>
<pre>
    char cmd = e.getActionCommand().charAt(0);
    display.setText(display.getText() + cmd);</pre>
<p>
	Wenn ein Operator gedrückt wurde, dann müssen wir die Instanzvariablen <em>operand1</em> und <em>operation</em> setzen, also</p>
<pre>
    operand1 = Double.parseDouble(display.getText());
    display.setText(&quot;&quot;);
    operation = cmd;</pre>
<p>
	Und wenn das &quot;=&quot; Zeichen gedrückt wurde, dann müssen wir die Berechnung durchführen und anzeigen:</p>
<pre>
    double operand2 = Double.parseDouble(display.getText());
    double result = calculate(operand1, operand2, operation);
    display.setText(&quot;&quot; + result);</pre>
<p>
	Es bleibt also lediglich die Methode <em>calculate(double operand1, double operand2, char operation)</em> zu implementieren.</p>
<p>
	.</p>
<hr />
<h1>
	Fragen</h1>
<ol>
	<li>
		Es gibt lokale Variablen, Instanzvariablen und Konstanten.&nbsp; Erklären Sie den Unterschied.<br />
		&nbsp;</li>
	<li>
		Was muß man ändern, damit aus &#39;PI&#39;&nbsp;eine Konstante wird?<br />
		<span style="font-family:courier new,courier,monospace;">double PI = 3.14;</span><br />
		&nbsp;</li>
	<li>
		Im folgenden Beispiel gibt es mehrere Variablen, teilweise mit gleichem Namen.&nbsp; Beschreiben Sie wie die Variablen zusammenhängen, und welche wo gültig sind.<br />
		<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp; public class Lifetime {<br />
		<br />
		&nbsp;&nbsp;&nbsp; public void run() {<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = 3;<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cow(i);<br />
		&nbsp;&nbsp;&nbsp; }<br />
		<br />
		&nbsp;&nbsp;&nbsp; private void cow( int n ) {<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;3; i++) {<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
		&nbsp;&nbsp;&nbsp; }<br />
		&nbsp; }</span><br />
		&nbsp;</li>
	<li>
		Nennen Sie drei verschiedene LayoutManager.<br />
		&nbsp;</li>
	<li>
		Skizzieren Sie wie die UI für den folgenden Code aussehen würde.<br />
		&nbsp;</li>
	<li>
		Wenn Sie auf einen JButton klicken, welche Art von Ereignis (Event) wird dann ausgelöst?</li>
</ol>
<p>
	.</p>
<hr />
<h1>
	Referenzen</h1>
<p>
	In diesem Kapitel ist die bevorzugte Referenz das Buch von Eric Robert [1].&nbsp; Ein schönes, allerdings anspruchvolles Tutorial ist das von Oracle, den Machern von Java [2].</p>
<p>
	[1] The Art and Science of Java, von Eric Roberts, Addison-Wesley, 2008</p>
<p>
	[2] The Swing Tutorial, <a href="http://docs.oracle.com/javase/tutorial/uiswing/">docs.oracle.com/javase/tutorial/uiswing/</a></p>
<p>
	.</p>
<p class="footer">
Copyright &copy; 2016-2021 <a href="http://www.lano.de">Ralph P. Lano</a>.  All rights reserved.
</p>
</div>
</center>
</div>
</body>
</html>