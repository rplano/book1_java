<!DOCTYPE html><html lang="de"><head>
  <title>Variationen zum Thema: Java</title>
  <meta name="title" content="Variationen zum Thema: Java">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta charset="UTF-8">
  <meta name="description" content="Introduction to Java Programming">
  <meta name="keywords" content="java,introduction">
  <meta name="author" content="Ralph P. Lano">
  <meta name="robots" content="index,follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="../book.css">
</head>
<body><center>
<div id="wrap">
	<ul class="sidenav">
	  <p><a href="index.html">Variationen zum Thema</a><a href="index.html">Java</a></p>
	  <li><a href="Karel.html">Karel</a></li>
	  <li><a href="Graphics.html">Graphics</a></li>
	  <li><a href="Console.html">Console</a></li>
	  <li><a href="Agrar.html">Agrar</a></li>
	  <li><a href="MindReader.html">MindReader</a></li>
	  <li><a href="Swing.html">Swing</a></li>
	  <li><a href="Asteroids.html">Asteroids</a></li>
	  <li><a href="Stocks.html">Stocks</a></li>
	</ul>
<div class="content"><p>
	<img alt="" src="../images/c24f32f0-1b68-42ac-a304-5a7e04e7d05b.png" style="display: block; margin-left: auto;  margin-right: auto; width: 364px; height: 307px;" /></p>
<h1>
	Stocks</h1>
<p>
	Das Buch neigt sich dem Ende zu, was normalerweise bedeutet, dass es jetzt richtig interessant wird. Wir werden lernen wie wir mit Dateien umgehen, also lesen und schreiben.&nbsp; Dann schauen wir mal was so alles schief gehen kann und wie man das verhindert.&nbsp; Danach erweitern wir unseren Horizont was Datenstrukturen angeht.&nbsp; Die Objektorientierte Analyse kommt als nächstes, und zum Schluß kommen noch Interfaces und Polymorphie.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/readFromFile.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Files</h2>
<p>
	Sobald wir den Computer ausschalten sind alle Daten futsch.&nbsp; Es sei denn man hat sie gespeichert.&nbsp; Gespeichert heißt man hat sie in eine Datei geschrieben.&nbsp; Das ist eigentlich ganz einfach.&nbsp; Wir fangen mit dem Lesen von Dateien an.</p>
<p>
	Zum Lesen aus Dateien muß man drei Dinge tun:</p>
<ol>
	<li>
		die Datei öffnen,</li>
	<li>
		lesen von der Datei, Zeile für Zeile, und</li>
	<li>
		die Datei schließen.</li>
</ol>
<p>
	Im Code sieht das dann so aus:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // open file
        <span style="color:#0000ff;">FileReader</span> fr = new FileReader(&quot;text.txt&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">BufferedReader</span> rd = new BufferedReader(fr);

        // read from file, line by line
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (true) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String line = <span style="color:#0000ff;">rd.readLine()</span>;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (<span style="color:#0000ff;">line == null</span>)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(line);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}

        // close file
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rd.close();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fr.close();</pre>
<p>
	In Java verwenden wir zum Lesen von Textdateien die Klasse <em>FileReader</em>.&nbsp; Der übergibt man einfach den Dateinamen der zu öffnenden Datei.&nbsp; Da der FileReader sehr dumm ist, er kann nämlich nur ein Zeichen nach dem anderen lesen, bittet man immer den <em>BufferedReader</em> um Hilfe: der kann nämlich ganze Zeilen lesen.&nbsp; Man übergibt den FileReader dem BufferedReader als Argument, damit der BufferedReader weiß welche Datei er denn lesen soll.</p>
<p>
	Dann benutzen wir einfach einen Loop-And-A-Half um Zeile für Zeile mittels der Methode <em>readLine()</em> aus der Datei zu lesen.&nbsp; Wir wissen, dass wir das Ende der Datei erreicht haben, wenn readLine() den Wert <em>null</em> zurückliefert.&nbsp; D.h. es gibt nix mehr zu lesen.&nbsp; Danach schließen wir die beiden Readers mit der <em>close()</em> Methode.</p>
<p>
	Leider funktioniert das Programm noch nicht ganz, weil es zu Fehlern (Exceptions) kommen kann.&nbsp; Dazu gleich mehr, aber vorher möchten wir in eine Datei schreiben.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/writeToFile.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Schreiben</h2>
<p>
	Auch beim Schreiben müssen wir drei Dinge tun:</p>
<ol>
	<li>
		die Datei zum Schreiben öffnen,</li>
	<li>
		dann in die Datei schreiben und</li>
	<li>
		die Datei schließen.</li>
</ol>
<p>
	Schreiben ist einfacher als Lesen, weil wir keinen BufferedDingens brauchen:</p>
<pre>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // open file
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">FileWriter</span> fw = new FileWriter(&quot;test.txt&quot;, false);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// write to file, one string at a time
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot;Enter text to write (&#39;.&#39; to quit): &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (true) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String line = readLine(&quot;&quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (line.equals(&quot;.&quot;))
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">fw.write(line + &quot;\n&quot;)</span>;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// close file
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fw.close();</pre>
<p>
	<img alt="" src="../images/testTxt.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 100px; float: right;" />Wir verwenden die Klasse <em>FileWriter</em> zum Schreiben von Textdateien.&nbsp; Wir übergeben als erstes den Dateinamen in den wir schreiben wollen, und wir müssen sagen ob wir anhängen wollen oder überschreiben wollen, falls die Datei schon existiert.&nbsp; Wenn wir anhängen wollen, sagen wir &quot;true&quot;, falls wir überschreiben wollen sagen wir &quot;false&quot;, also nicht anhängen.</p>
<p>
	Dann benutzen wir wieder den Loop-And-A-Half um Zeile für Zeile mittels der Methode <em>write()</em> zu schreiben.&nbsp; Interessant ist vielleicht noch das &#39;\n&#39;: es ist das Zeichen für <em>new line</em>, und sorgt dafür, dass der nächste String in der &quot;test.txt&quot; Datei in eine neue Zeile geschrieben wird.</p>
<p>
	Damit wir nicht in einer Endlosschleife hängen bleiben, checken wir ob der Nutzer einen Punkt eingegeben hat, das ist unser Abbruchkriterium.&nbsp; Danach schließen wir unseren Writer mit der <em>close()</em> Methode.</p>
<p>
	.</p>
<h2>
	Exceptions</h2>
<p>
	Was ist wenn was schief geht?&nbsp; Oder erst mal, was kann denn schief gehen?&nbsp; Es könnte z.B. sein, dass es die Datei die wir zum Lesen öffnen möchten gar nicht gibt.&nbsp; Dann kommt es zu einer <em>FileNotFoundException</em>.&nbsp; Eclipse zeigt die sogenannte <em>StackTrace</em> im &quot;Console&quot; Fenster:</p>
<p>
	<img alt="" src="../images/eception.png" style="margin-left: 10px; margin-right: 10px; width: 800px; height: 200px;" /></p>
<p>
	An der Fehlermeldung erkennt man, dass es die Datei &quot;text.txt&quot; nicht gibt.&nbsp; Die StackTrace sagt einem auch wo denn der Fehler im eigenen Programm ausgelöst wurde.&nbsp; Dazu muss man die Klassen der Reihe nach durchgehen bis man seine eigene findet, in dem Fall oben ist das die <em>ReadFromFile</em> Klasse.&nbsp; Und dort steht &quot;ReadFromFile.java:25&quot;, und die &quot;25&quot; ist die Zeilennummer in der das Problem auftrat.&nbsp; Wir können aber auch einfach auf den Link klicken, und Eclipse navigiert dann den Cursor an die problematische Stelle.</p>
<p>
	Kann noch was schief gehen?&nbsp; Ja.&nbsp; Z.B. könnte es sein, dass die Datei zwar existiert, wir sie aber nicht lesen dürfen, da wir keine Berechtigung dazu haben.&nbsp; Dann kommt es auch zu einer FileNotFoundException, aber dieses mal steht in Klammern &quot;Permission denied&quot;.&nbsp; Auch beim Schreiben können Sachen schief gehen, z.B. kann es sein, dass wir keine Schreibberechtigung haben, oder es könnte sein, dass wir keinen freien Platz mehr auf der Festplatte haben.</p>
<p>
	Was passiert denn mit unserem Programm, wenn es zu einer Exception kommt?&nbsp; Es stürzt ab.&nbsp; Das kann sehr unangenehm sein, z.B. wenn das Programm ein Flugzeug steuert in dem wir sitzen, denn dann stürzt auch das Flugzeug ab.&nbsp; Nicht gut.</p>
<p>
	.</p>
<h2>
	Try-Catch</h2>
<p>
	Wir müssen also das Flugzeug auffangen, oder besser das Programm.&nbsp; Das machen wir mit <em>catch</em>:&nbsp; wir probieren erst mal (<em>try</em>) ob alles funktioniert, wenn ja gut, wenn nein, dann sagen wir dem Programm was es tun soll.&nbsp; Im Code sieht das dann so aus:</p>
<pre>
&nbsp;   try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   // code for file access
        ...
&nbsp;   } catch ( Exception ex ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   // deal with exception
        ...
&nbsp;   }
    ...
</pre>
<p>
	Wir umgeben also unseren problematischen Code mit einem try-Block.&nbsp; Klappt alles, dann macht das Programm ganz normal weiter (der catch-Block wird nicht ausgeführt).&nbsp; Geht aber was schief, dann bricht das Programm nicht ab, sondern springt in den catch-Block und führt diesen aus.&nbsp; Danach geht das Programm davon aus, dass wir alles unter Kontrolle haben, und führt den Code nach dem catch-Block aus, wie wenn nichts gewesen wäre.</p>
<p>
	Exceptions treten nicht nur beim Arbeiten mit Dateien auf, sondern auch in vielen anderen Umständen.&nbsp; Betrachten wir kurz die wichtigsten:</p>
<p>
	<strong>NullPointerException:</strong>&nbsp; ist wohl die am häufigsten vorkommende Exception.&nbsp; Sie tritt immer dann auf, wenn ein Objekt nicht existiert, also noch keines mit <em>new</em> angelegt wurde:</p>
<pre>
        GRect fritz = null;
        fritz.setColor(Color.RED);</pre>
<p>
	<strong>ArithmeticException:</strong>&nbsp; tritt auf wenn eine mathematische Berechnung nicht möglich ist, der Klassiker, Division durch null:</p>
<pre>
        int x = 5 / 0;</pre>
<p>
	<strong>NumberFormatException:</strong>&nbsp; wenn wir versuchen aus einem String eine Zahl zu machen, und der String aber keine Zahl enthält:</p>
<pre>
        int x = Integer.parseInt(&quot;five&quot;);</pre>
<p>
	<strong>ArrayIndexOutOfBoundsException:</strong>&nbsp; wenn wir versuchen auf Elemente eines Arrays zuzugreifen, die es gar nicht gibt:</p>
<pre>
        int[] eggs = { 0, 1, 2, 3 };
        println( eggs[5] );</pre>
<p>
	.</p>
<h2>
	Data Structures</h2>
<p>
	Bisher kennen wir nur eine Datenstruktur, das Array.&nbsp; Arrays sind zwar o.k., aber so richtig toll sind sie nicht.&nbsp; Viel cooler sind da schon die <em>ArrayList</em> und die <em>HashMap</em> mit denen wir uns gleich beschäftigen werden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/uniqueNames.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 200px; float: right;" />ArrayList</h2>
<p>
	ArrayListen sind wie Arrays nur schlauer.&nbsp; Fangen wir an eine ArrayList zu deklarieren und zu instantiieren:</p>
<pre>
&nbsp;   ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
</pre>
<p>
	Wir legen also eine ArrayList mit dem Namen &quot;names&quot; an, und in diese ArrayList dürfen nur &lt;Strings&gt; rein, das ist was die spitzen Klammern sagen.&nbsp; Im Prinzip ist es dasselbe wie wenn wir Arrays verwendet hätten:</p>
<pre>
&nbsp;   String[] names = new String[10];
</pre>
<p>
	Allerdings einen Unterschied erkennen wir sofort: bei Arrays mussten wir sagen wieviele Strings wir reintun wollen, bei der ArrayList ist das nicht notwendig: die ArrayList kann nämlich wachsen und schrumpfen, je nach Bedarf.&nbsp; Das ist super-praktisch!</p>
<p>
	Machen wir weiter.&nbsp; Wir wollen jetzt ein paar Namen in unsere Namensliste einfügen, allerdings nur, falls der Name noch nicht in der Liste ist.&nbsp; Das geht so:</p>
<pre>
&nbsp;&nbsp; &nbsp;while (true) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = readLine(&quot;Enter new name: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!names.<span style="color:#0000ff;">contains</span>(name)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;names.<span style="color:#0000ff;">add</span>(name);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}
</pre>
<p>
	Wir fragen mit der Methods <em>contains()</em> ob ein bestimmter Name schon in der Liste ist.&nbsp; Falls nicht, dann fügen wir ihn mit <em>add()</em> hinzu.&nbsp; Wir müssen also auch keinen Index beim Hinzufügen angeben, neue Einträge werden einfach am Ende der Liste eingefügt.&nbsp; Wir können aber auch Einträge irgendwo in der Liste einfügen, dann müssen wir aber den Index angeben.</p>
<p>
	Wenn wir jetzt unsere Namensliste ausdrucken wollen, dann müssen wir über die Liste iterieren:</p>
<pre>
&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; names.<span style="color:#0000ff;">size</span>(); i++) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(names.<span style="color:#0000ff;">get</span>(i));
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Mit der Methode <em>size()</em> können wir feststellen wieviele Einträge unsere Liste hat, und mit <em>get()</em> lesen wir den Eintrag an einer bestimmten Position.&nbsp; Zusätzlich hat die ArrayList noch folgende praktische Methoden:</p>
<ul>
	<li>
		<strong>set():</strong>&nbsp; ersetzt den Eintrag an einer bestimmten Position mit einem neuen</li>
	<li>
		<strong>indexOf():</strong>&nbsp; sucht nach einem Eintrag und gibt die Position zurück</li>
	<li>
		<strong>remove():</strong>&nbsp; entfernt einen Eintrag aus der Liste</li>
	<li>
		<strong>clear():</strong>&nbsp; löscht die komplette Liste.</li>
</ul>
<p>
	Also, wie wir sehen sind ArrayLists viel besser als Arrays, und deswegen nach langer Zeit wieder mal ein SEP:</p>
<p>
	<strong><strong>SEP: Man sollte immer ArrayList anstelle von Array verwenden (Ausnahme sind Bilder).</strong></strong></p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/phoneBook.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 300px; float: right;" />HashMap</h2>
<p>
	HashMaps sind wahrscheinlich die praktischste aller Datenstrukturen, weil man in ihnen super suchen kann.&nbsp; Klassische Beispiele sind Telefonbücher und Wörterbücher.&nbsp; Schauen wir uns das Beispiel PhoneBook mal näher an.&nbsp; Wir beginnen mit der Deklaration:</p>
<pre>
&nbsp;   HashMap&lt;String, Integer&gt; phoneBook = new HashMap&lt;String, Integer&gt;();</pre>
<p>
	Das sieht etwas ähnlich wie bei einer ArrayList aus, allerdings sind hier in der spitzen Klammern zwei Datentypen, ein String und ein Integer: &lt;String, Integer&gt;.&nbsp; Das erste ist der Schlüssel (key) und das zweite der Wert (value).&nbsp; Eine HashMap assoziiert also mit einem Schlüssel einen Wert, deswegen nennt man sie manchmal auch assoziative Arrays. &nbsp;</p>
<p>
	Fügen wir mal ein paar Werte in unser PhoneBook:</p>
<pre>
&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = readLine(&quot;Enter name: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int number = readInt(&quot;Enter number: &quot;);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;phoneBook.<span style="color:#0000ff;">put</span>(name, number);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Einfügen geht mit der Methode <em>put()</em>.&nbsp; Wir übergeben ihr einfach einen Namen und eine Nummer.&nbsp; Exisitiert der Name bereits in der Map, dann wird er überschrieben, falls nicht wird er neu eingefügt.&nbsp; In einer HashMap kann es nie zwei Einträge mit gleichem Namen geben, Schlüssel müssen eindeutig sein.</p>
<p>
	Nachdem wir unser PhoneBook gefüllt haben, wollen wir mal darin suchen, denn das ist ja wofür die HashMap gut sein soll:</p>
<pre>
&nbsp;&nbsp;&nbsp; String name = readLine(&quot;Enter name to search: &quot;);
&nbsp;&nbsp; &nbsp;if (phoneBook.<span style="color:#0000ff;">containsKey</span>(name)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(phoneBook.<span style="color:#0000ff;">get</span>(name));
&nbsp;&nbsp; &nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot;no entry for this name&quot;);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Mit der <em>containsKey()</em> Methode können wir testen ob ein Name in der Map existiert, und mit <em>get()</em> können wir uns dann die Nummer zu dem Namen geben lassen.&nbsp; Das sieht zwar sehr ähnlich wie bei der ArrayList aus, ist aber viel cooler: bei der ArrayList müssen wir den Index des Eintrags kennen, bei der Map sagen wir einfach: gib mir mal.</p>
<p>
	Zum Schluß wollen wir mal sehen was in unserer Map drinnen ist:</p>
<pre>
&nbsp;&nbsp;&nbsp; for (String name : phoneBook.<span style="color:#0000ff;">keySet</span>()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int number = phoneBook.<span style="color:#0000ff;">get</span>(name);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(name + &quot;: &quot; + number);
&nbsp;&nbsp; &nbsp;}</pre>
<p>
	Das ist jetzt komplett neu: die erste Zeile macht überhaupt keinen Sinn.&nbsp; Das Problem mit den Maps ist, dass es da keine Nummern mehr gibt.&nbsp; Wir können nicht sagen gib mir mal das zweite Element, denn eine Map hat keinen Index.&nbsp; Es gibt auch keine wirklich feste Reihenfolge, d.h. die Reihenfolge in der die Einträge ausgegeben werden, kann komplett anders sein als die Reihenfolge in der sie eingegeben wurden (wie man im Beispiel rechts sieht).&nbsp;</p>
<p>
	Deswegen der Trick mit der Pseudo-for-Schleife:</p>
<pre>
&nbsp;&nbsp;&nbsp; for (String name : phoneBook.<span style="color:#0000ff;">keySet</span>()) {</pre>
<p>
	Die heißt soviel wie, gib mir mal einen Namen aus der Liste der Namen in der Map.&nbsp; Und danach, gibst Du mir den nächsten, usw. bis wir alle durch sind.&nbsp; Wenn man das akzeptiert hat, ist der Rest einfach.</p>
<p>
	.</p>
<h2>
	Objekt-Orientierte Analyse</h2>
<p>
	Wir befinden uns gerade an einem Übergang:&nbsp; und zwar verlassen wir gerade die prozedurale Ein-Klassen-Welt und betreten die objekt-orientierte Mehr-Klassen-Welt.&nbsp; Der Übergang ist nicht ganz schmerzfrei.&nbsp; Und wo uns bisher der Top-Down Ansatz wirklich gute Dienste erwiesen hat, hilft er uns jetzt nur noch im Kleinen, nicht mehr aber im Großen weiter.</p>
<p>
	Dafür gibt es jetzt aber die Objekt-Orientierte Analyse, manchmal einfach auch Anforderungsanalyse genannt.&nbsp; Bevor man also anfängt Code zu schreiben, überlegt man sich erst einmal was will man denn überhaupt.&nbsp; Das schreibt man dann am besten in möglichst einfachen Sätzen nieder.&nbsp; Z.B. könnten die Anforderungen für einen Webshop so fomuliert werden:</p>
<p style="margin-left: 40px;">
	&quot;Der Azamon Shop hat Artikel und Warenkörbe.&nbsp; Ein Artikel hat einen Namen, einen Typ und einen Preis.&nbsp; Ein Warenkorb hat einen Benutzernamen und eine Liste von Artikel.&nbsp; Wir können alle Artikel des Shops auflisten.&nbsp; Wir können alle Artikel in einem Warenkorb auflisten.&nbsp; Wir können einen Artikel in den Warenkorb legen.&nbsp; Wir können den Preis aller Artikel in einem Warenkorb berechnen.&quot;</p>
<p>
	Diese Anforderungen sind die Basis für unsere Objekt-Orientierte Analyse.&nbsp;</p>
<p>
	<strong>1.Schritt:</strong>&nbsp; In ersten Schritt dieser Analyse nehmen wir einen Farbstift und unterstreichen die Verben grün und die Substantive mit rot:</p>
<p style="margin-left: 40px;">
	&quot;Der <span style="color:#ff0000;">Azamon Shop</span> <span style="color:#00ff00;">hat</span> <span style="color:#ff0000;">Artikel</span> und <span style="color:#ff0000;">Warenkörbe</span>.&nbsp; Ein <span style="color:#ff0000;">Artikel</span> <span style="color:#00ff00;">hat</span> einen <span style="color:#ff0000;">Namen</span>, einen <span style="color:#ff0000;">Typ</span> und einen <span style="color:#ff0000;">Preis</span>.&nbsp; Ein <span style="color:#ff0000;">Warenkorb</span> <span style="color:#00ff00;">hat</span> einen <span style="color:#ff0000;">Benutzernamen</span> und eine Liste von <span style="color:#ff0000;">Artikel</span>.&nbsp; Wir können alle <span style="color:#ff0000;">Artikel</span> des <span style="color:#ff0000;">Shops</span> <span style="color:#00ff00;">auflisten</span>.&nbsp; Wir können alle <span style="color:#ff0000;">Artikel</span> in einem <span style="color:#ff0000;">Warenkorb</span> <span style="color:#00ff00;">auflisten</span>.&nbsp; Wir können einen <span style="color:#ff0000;">Artikel</span> in den <span style="color:#ff0000;">Warenkorb</span> <span style="color:#00ff00;">legen</span>.&nbsp; Wir können den <span style="color:#ff0000;">Preis</span> aller <span style="color:#ff0000;">Artikel</span> in einem <span style="color:#ff0000;">Warenkorb</span> <span style="color:#00ff00;">berechnen</span>.&quot;</p>
<p>
	<strong>2.Schritt:</strong>&nbsp; Im zweiten Schritt machen wir eine Liste für die Verben:</p>
<ul>
	<li>
		hat</li>
	<li>
		auflisten</li>
	<li>
		auflisten</li>
	<li>
		legen</li>
	<li>
		berechnen</li>
</ul>
<p>
	und die Substantive listen und zählen wir:</p>
<ul>
	<li>
		Shop: II</li>
	<li>
		Artikel: IIIIIII</li>
	<li>
		Warenkorb: IIIII</li>
	<li>
		Name: I</li>
	<li>
		Typ: I</li>
	<li>
		Preis: II</li>
	<li>
		Benutzername: I</li>
</ul>
<p>
	Das Zählen ist nicht unbedingt notwendig, hilft aber ein bischen zu erkennen was wichtig ist.&nbsp;</p>
<p>
	<strong>3.Schritt:</strong>&nbsp; Im dritten Schritt betrachten wir die Liste der Substantive.&nbsp; Welche der Substantive können wir mit einem einfachen Datentyp wie einem <em>int</em>, <em>double</em>, <em>String</em> etc. beschreiben?</p>
<ul>
	<li>
		Shop: ???</li>
	<li>
		Artikel: ???</li>
	<li>
		Warenkorb: ???</li>
	<li>
		Name: String</li>
	<li>
		Typ: String</li>
	<li>
		Preis: int</li>
	<li>
		Benutzername: String</li>
</ul>
<p>
	Wenn etwas kompliziert ist, also aus anderen Teilen besteht, wie z.B. Shop, Artikel und Warenkorb, dann handelt es sich um einen komplizierten Datentypen, also eine Klasse.&nbsp; Wir haben also unsere Klassen identifiziert:&nbsp; <em>Shop</em>, <em>Artikel</em> und <em>Warenkorb</em>.&nbsp;</p>
<p>
	<strong>4.Schritt:</strong>&nbsp; Im vierten Schritt geht es darum die richtigen Attribute den richtigen Klassen zuzuweisen.&nbsp; Dazu lesen wir einfach noch einmal unsere Anforderungen durch.&nbsp; Dort steht:</p>
<ul>
	<li>
		&quot;Der Azamon Shop hat Artikel und Warenkörbe.&quot;:&nbsp; also offensichtlich gehören <em>Artikel</em> und <em>Warenkorb</em> zum <em>Shop</em>, sind also Attribute des Shop.</li>
	<li>
		&quot;Ein Artikel hat einen Namen, einen Typ und einen Preis.&quot;:&nbsp;&nbsp; also gehören Namen, Typ und Preis zum <em>Artikel</em>.</li>
	<li>
		&quot;Ein Warenkorb hat einen Benutzernamen und eine Liste von Artikel&quot;:&nbsp; also gehören Benutzernamen und Liste von Artikel zum <em>Warenkorb</em>.</li>
</ul>
<p>
	An dieser Stelle macht es auch Sinn auf Plural zu achten: jedes mal wenn ein Wort im Plural vorkommt, dann bedeutet das, dass wir eine Liste (oder Map) von dem jeweiligen Attribute benötigen.&nbsp; Z.B. aus &quot;Liste von Artikel&quot; oder &quot;Warenkörbe&quot; wird dann eine ArrayList.</p>
<p>
	<img alt="" src="../images/5e5039fa-0351-444b-b855-7fc03777b3ab.png" style="width: 221px; height: 170px; float: right;" />Mit der Information können wir schon unsere Klassen mit Attributen hinschreiben:</p>
<pre>
public class Shop {
    private ArrayList&lt;Cart&gt; carts;
    private ArrayList&lt;Article&gt; articles;
}

public class Article {
&nbsp;&nbsp; &nbsp;private String name;
&nbsp;&nbsp; &nbsp;private String type;
&nbsp;&nbsp; &nbsp;private int price;
}

public class Cart {
&nbsp;&nbsp; &nbsp;private String userName;
&nbsp;&nbsp; &nbsp;private ArrayList&lt;Article&gt; articles;
}</pre>
<p>
	<strong>5.Schritt:</strong>&nbsp; Beim letzten Schritt geht es darum die Methoden den richtigen Klassen zuzuweisen.&nbsp; Aus den Verben die wir im zweiten Schritt gesammelt haben, werden die Methoden (wir haben ja schon immer gesagt, dass Methoden Tun-Wörter sind).&nbsp; Wir gehen ein Verb nach dem anderen durch.&nbsp;</p>
<ul>
	<li>
		hat:&nbsp; &quot;hat&quot; zählt nicht als Verb, da es Zugehörigkeit ausdrückt und schon im Schritt 4 verwendet wurde.</li>
	<li>
		auflisten:&nbsp; bezieht sich auf &quot;Wir können alle Artikel des Shops auflisten&quot;, von daher gehört es zum Shop, und sollte <em>artikelAuflisten()</em> heißen.</li>
	<li>
		auflisten:&nbsp; bezieht sich auf &quot;Wir können alle Artikel in einem Warenkorb auflisten&quot;, von daher gehört es zum Warenkorb, und sollte <em>artikelAuflisten()</em> heißen.</li>
	<li>
		legen:&nbsp; bezieht sich auf &quot;Wir können einen Artikel in den Warenkorb legen&quot;, von daher gehört es zum Warenkorb, und sollte <em>artikelInWarenkorbLegen()</em> heißen.</li>
	<li>
		berechnen&nbsp; bezieht sich auf &quot;Wir können den Preis aller Artikel in einem Warenkorb berechnen&quot;, von daher gehört es zum Warenkorb, und sollte <em>preisAllerArtikelImWarenkorbBerechnen()</em> heißen.</li>
</ul>
<p>
	Und damit stehen unsere Klassen, ihre Attribute und Methoden fest:</p>
<pre>
public class Shop {
    private ArrayList&lt;Cart&gt; carts;
    private ArrayList&lt;Article&gt; articles;

&nbsp;&nbsp; &nbsp;public void listArticles() {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;}
}

public class Article {
&nbsp;&nbsp; &nbsp;private String name;
&nbsp;&nbsp; &nbsp;private String type;
&nbsp;&nbsp; &nbsp;private int price;
}

public class Cart {
&nbsp;&nbsp; &nbsp;private String userName;
&nbsp;&nbsp; &nbsp;private ArrayList&lt;Article&gt; articles;

&nbsp;&nbsp; &nbsp;public void listArticles() {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void addArticleToCart() {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;public void calculatePriceOfArticlesInCart() {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Was noch bleibt ist sich zu überlegen welche Parameter die Methoden benötigen und was sie als Rückgabewert liefern.&nbsp; Es schadet auch nie, jeder Klasse einen Constructor zu geben.&nbsp; Und natürlich fehlt noch der Code.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/8aff1c4e-4764-43d9-9651-6f407d47f9fe.png" style="width: 171px; height: 154px; float: right;" />Interfaces</h2>
<p>
	Wir kommen jetzt zum letzten Thema dieses Kapitels: <em>Interfaces</em>.&nbsp; Wir haben bereits gehört, dass es in Java keine Mehrfachvererbung gibt, also eine Klasse kann keine zwei Eltern haben.&nbsp; Bisher war das kein Problem, aber jetzt wo wir anfangen größere Programme zu schreiben, stellt sich das schon als ärgerlich heraus.&nbsp; Die Lösung ist, wer hätte es vermutet: <em>Interfaces</em>.</p>
<p>
	Interfaces erlauben uns zwei Dinge zu tun:</p>
<ul>
	<li>
		Konstanten zwischen verschiedenen Klassen zu teilen und</li>
	<li>
		das Definieren einer Schnittstelle zwischen zwei Klassen, daher der Name.</li>
</ul>
<p>
	<img alt="" src="../images/da024ab5-e8a1-4c12-a38a-39b446de513d.png" style="width: 271px; height: 137px; float: right;" />Beginnen wir mit dem ersten.&nbsp; In dem Projekt MinesClone hatten wir ein Interface namens <em>MinesConstant</em>:</p>
<pre>
public <span style="color:#0000ff;">interface</span> MinesConstant {
    /** Playing field should be 8x8 fields and 50 pixel per field */
    public static final int FIELD_SIZE = 8;
    public static final int PIXEL_PER_TILE = 50;
    ...
}</pre>
<p>
	Wir hatten also alle Konstanten an einer Stelle.&nbsp; Damit diese Konstanten in anderen Klassen verwenden konnten, mussten wir in den Klassen <em>MinesClone</em> und <em>MinesHelper</em> dieses Interface implementieren:</p>
<pre>
public class MinesClone extends GraphicsProgram <span style="color:#0000ff;">implements MinesConstant</span> {
    ...
}

public class MinesHelper <span style="color:#0000ff;">implements MinesConstant</span> {
    ...
}</pre>
<p>
	Ganz einfach.</p>
<p>
	<img alt="" src="../images/bd4667e8-8f4d-4567-8360-74950dbd6590.png" style="width: 300px; height: 132px; float: right;" />Kommen wir zum Definieren einer Schnittstelle zwischen zwei Klassen.&nbsp; Betrachten wir die ACM Grafikklassen:&nbsp; wir haben ja schon gehört, dass GLabel, GRect und GOval Kinderklassen von GObject sind.&nbsp; Zusätzlich gibt es aber noch ein Interface <em>GFillable</em>, und die Klassen GRect und GOval implementieren dieses Interface.&nbsp; Für GLabel macht das keinen Sinn, denn was soll denn bitte ein ausgefüllter GLabel sein?</p>
<p>
	Warum ist jetzt GFillable eine Schnittstelle zwischen zwei Klassen?&nbsp; Betrachten wir unser aller erstes Grafikprogramm BlueRect:&nbsp; Wir wollten ein ausgefülltes Rechteck zeichnen.&nbsp; Da GRect das GFillable Interface implementiert, wissen wir, dass GRect die Methoden <em>setFilled()</em> und <em>setFillColor()</em> hat.&nbsp; Also die Klasse BlueRect kann sich darauf verlassen, dass es diese beiden Methoden gibt.&nbsp; Umgekehrt verpflichtet sich die Klasse GRect, dass es diese beiden Methoden liefert, da sie ja das Interface GFillable implementiert.&nbsp; Es ist also ein Vertrag zwischen den beiden Klassen BlueRect und GRect.&nbsp; Manchmal wird das auch als &quot;Design by contract (DbC)&quot; [1] bezeichnet.</p>
<p>
	Wie muss jetzt das GFillable Interface aussehen?</p>
<pre>
public interface GFillable {
&nbsp;&nbsp;&nbsp; public void setFilled(boolean flag);
&nbsp;&nbsp; &nbsp;public boolean isFilled();
&nbsp;&nbsp; &nbsp;public void setFillColor(Color c);
&nbsp;&nbsp; &nbsp;public Color getFillColor();
}
</pre>
<p>
	Wir sehen also, in der Definition des Interfaces werden Methoden nur angedeutet, aber nicht implementiert.&nbsp; Die Implementierung muss in der jeweiligen Klasse erfolgen, Interfaces dürfen keinen Implementierungscode enthalten.&nbsp;</p>
<p>
	In der ACM Bibliothek gibt es noch die Interfaces <em>GResizable</em>, welches die Klassen GImage, GOval and GRect implementieren, sowie <em>GScalable</em>, welches die Klassen GArc, GCompound, GLine, GImage, GOval, GPolygon and GRect implementieren.&nbsp; Wir sehen also, obwohl es in Java nur Einfachvererbung zwischen Klassen gibt, so dürfen Klassen durchaus mehrere Interfaces implementieren.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/polymorphism.png" style="margin-left: 10px; margin-right: 10px; width: 200px; height: 133px; float: right;" />Polymorphism</h2>
<p>
	Polymorphismus bedeutet Vielgestaltigkeit.&nbsp; Und was hat das bitte mit Java zu tun?&nbsp; Schauen wir uns ein Beispiel an:</p>
<pre>
public class Polymorphism extends GraphicsProgram {

&nbsp;&nbsp; &nbsp;public void run() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;GRect frankWalter = new GRect(50, 30);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;add(frankWalter, 50, 50);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fillWithRedColor(frankWalter);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 10; i++) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;moveByTenPixelToLeft(frankWalter);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;pause(1000);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void <span style="color:#0000ff;">fillWithRedColor(GFillable rect)</span> {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rect.setFilled(true);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rect.setFillColor(Color.RED);
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void <span style="color:#0000ff;">moveByTenPixelToLeft(GObject rect)</span> {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rect.move(10, 0);
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Das GRect <em>frankWalter</em> ist vielgestaltig.&nbsp; Denn gegenüber der Methode <em>fillWithRedColor()</em> gibt es sich als GFillable aus, während es sich gegenüber der Methode <em>moveByTenPixelToLeft()</em> als GObject ausgibt.&nbsp; Es hat also zwei Gestalten, GFillable und GObject.&nbsp; Mehr ist da nicht.</p>
<p>
	So und damit sind wir am Ende.&nbsp; Wir kennen jetzt nämlich alle drei Säulen der objektorientierten Programmierung:</p>
<ul>
	<li>
		Datenkapselung und Information Hiding</li>
	<li>
		Vererbung und Komposition</li>
	<li>
		Polymorphismus</li>
</ul>
<p>
	<img alt="" src="../images/e5c22719-1927-42b8-86c6-2c21661acdaf.png" style="width: 273px; height: 229px;" /></p>
<p>
	.</p>
<hr />
<h1>
	Review</h1>
<p>
	Es wurde wirklich Zeit, dass wir gelernt haben wie man mit Dateien arbeitet.&nbsp; Auch die Fehlerbehandlung hätte eigentlich schon viel früher kommen sollen, aber macht natürlich viel mehr Sinn wenn man mit Dateien arbeitet.&nbsp; Was wirklich neu und sich für die Zukunft als sehr nützlich erweisen wird, sind die Datenstrukturen ArrayList and HashMap.&nbsp; Die werden uns noch so manches Mal das Leben erleichtern.&nbsp; Und wir haben die Themen Interfaces und Polymorphie abgehackt.&nbsp;</p>
<p>
	Das wichtigste in diesem Kapitel war aber die Objekt-Orientierte Analyse, sozusagen Top-Down 2.0.</p>
<p>
	.</p>
<hr />
<h1>
	Projekte</h1>
<p>
	Hat sich die Arbeit gelohnt?&nbsp; Ich denke die Projekte in diesem Kapitel geben eine klare Antwort: Ja!</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/copyFile.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />CopyFile</h2>
<p>
	Als kleine Aufwärmübung wollen wir eine Text-Datei kopieren.&nbsp; Der Nutzer soll angeben welche Datei kopiert werden soll.&nbsp; Die Zieldatei soll einfach &quot;copy.txt&quot; heißen.&nbsp;</p>
<p>
	Im Prinzip gibt es zwei Möglichkeiten dies zu tun: man könnte die gesamten Daten aus der ersten Datei in einen String lesen, und dann in einem Schwung in die Datei&quot;copy.txt&quot; schreiben.&nbsp; Der Nachteil dieses Verfahrens, es ist ungeeignet für sehr große Dateien.&nbsp; Deswegen wollen wir die zweite Möglichkeit umsetzen:&nbsp; Wir öffenen beide Dateien, die erste mit dem FileReader zum Lesen, die zweite mit dem FileWriter zum schreiben.&nbsp; Dann lesen wir Zeile für Zeile, und schreiben jede Zeile sofort in den FileWriter.&nbsp; Wenn wir dann fertig sind müssen wir natürlich beide Dateien wieder schließen.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/minutes.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />Minutes</h2>
<p>
	Manchmal sind wir in den Team-Meetings fürs Protokoll zuständig.&nbsp; Dann wäre es ganz praktisch ein Programm fürs Protokoll zu haben.&nbsp; Die Idee ist folgende: man tippt einfach einen Satz, drückt auf <em>Enter</em> und die Zeile wird in eine Datei namens &quot;minutes.txt&quot; gespeichert.&nbsp; Man öffnet also eine Datei mittels FileWriter, liest dann kontinuierlich (Loop-and-a-Half) Zeile für Zeile von der Console mittels <em>readLine()</em>, und schreibt jede Zeile sofort in die Datei.&nbsp; Natürlich benötigen wir noch ein Abbruchkriterium (Sentinel), das könnte einfach eine leere Zeile sein.&nbsp; Danach dürfen wir natürlich nicht vergessen die Datei zu schließen.&nbsp; Eine nützliche Erweiterung wäre wenn man an jede Zeile die Uhrzeit anfügt, wann der Text eingegeben wurde.&nbsp; Dann würde unser Programm wirklich seinen Namen verdienen.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/wordCount.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />WordCount</h2>
<p>
	WordCount ist ein ganz einfaches Programm: liest eine bestimmte Datei ein und zählt die Zeilen, die Wörter und die Zeichen die diese Datei enthält.&nbsp; Wir verwenden den FileReader zusammen mit dem BufferedReader um Zeile für Zeile zu lesen.&nbsp; Wir benötigen drei Variablen zum zählen</p>
<pre>
    int counterLines = 0;
    int counterWords = 0;
    int counterChars = 0;</pre>
<p>
	(das dürfen lokale Variablen sein).&nbsp; Die Zeilen zu zählen ist ganz einfach, die Zeichen, auch denn mittels <em>line.length()</em> wissen wir wieviel Zeichen in einer Zeile sind.&nbsp; Für das Zählen der Wörter könnte man entweder den StringTokenizer nehmen, oder die Methode <em>split()</em> der String Klasse verwenden:</p>
<pre>
    private int countWords(String line) {
        String[] words = line.split(&quot; &quot;);
        return words.length;
    }</pre>
<p>
	Die Methode <em>split()</em> ist etwas mit Vorsicht zu geniesen.&nbsp; Denn augenscheinlich sieht es so aus, wie wenn sie einfach einen String in seine Einzelteile zerschneiden würde, und diese Einzelteile in einem String-Array speichert.&nbsp; Das tut sie auch, allerdings stellt sich die Frage, nach welchem Kriterium schneidet sie denn den String auseinander?&nbsp; Im Gegensatz zum StringTokenizer, der einfach eine Liste von Trennzeichen nimmt um einen String zu zerteilen, verwendet die <em>split()</em> Methode <em>Reguläre Ausdrücke</em>.&nbsp; Solange wir also nicht wissen was <em>Reguläre Ausdrücke</em> sind (kommt nächstes Semester) sollten wir die <em>split()</em> Methode eigentlich nicht verwenden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/createRandomNumbers.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />CreateFileWithRandomNumbers</h2>
<p>
	Ab und zu (z.B. im nächsten Projekt) benötigen wir eine Datei mit ein paar Zufallszahlen.&nbsp; Das könnten aber auch Zufallsnamen oder Adressen oder was auch immer sein.&nbsp; Der Nutzer soll uns angeben wie die Datei heißen soll in die wir die Zufallszahlen schreiben sollen, dann benötigen wir den Bereich in dem die Zahlen sein sollen, und wir müssten noch wissen wieviele Zahlen wir generieren sollen.&nbsp; Das Programm soll dann mittels FileWriter und RandomGenerator eine solche Datei erzeugen.&nbsp; Für das nächste Projekt benötigen wir Zufallszahlen zwischen 0 und 100, und zwar 43 an der Zahl.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/histogram.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 175px;" />Histogram</h2>
<p>
	Um sich z.B. mal ganz schnell einen Überblick über die Notenverteilung in einer Prüfung zu schaffen, kann man sich ein Histogramm ausgeben lassen.&nbsp; Man kann das natürlich mit einer tollen Grafik machen (kommt später), aber viel einfacher zu programmieren ist das mit einem Konsolenprogramm.&nbsp;</p>
<p>
	Wir wollen Punkte kummulieren, also zählen wieviele Klausuren Punkte zwischen 0 und 9, zwischen 10 und 19, usw hatten.&nbsp; Wir könnten z.B. ein Array für elf Zahlen definieren:</p>
<pre>
    private int[] histogramData = new int[11];</pre>
<p>
	und dann diese mit der Hilfe unseres Freunds Ganzzahldivision befüllen:</p>
<pre>
    private void putScoreInHistogram(int score) {
        histogramData[score / 10]++;
    }</pre>
<p>
	Die Zeile hat es in sich.&nbsp; Nach genügend langer Bewunderung können wir jetzt aber weiter machen.&nbsp;</p>
<p>
	Wir lesen also Zeile für Zeile aus unserer Scores.txt Datei, konvertieren die Strings mittels</p>
<pre>
    int score = Integer.parseInt(line);</pre>
<p>
	in Ganzzahlen und fügen die dann mittels unserer Wundermethode <em>putScoreInHistogram()</em> in unser Array.&nbsp; Wenn wir fertig sind, gehen wir das Array durch und geben es auf der Konsole aus.&nbsp; Wir könnten einfach die Zahlen ausgeben, viel hübscher sind aber kleine Sternchen (Asterisk nicht Asterix!):</p>
<pre>
    private String convertToStars(int i) {
        String stars = &quot;&quot;;
        for (int j = 0; j &lt; i; j++) {
            stars += &quot;*&quot;;
        }
        return stars;
    }</pre>
<p>
	.</p>
<h2>
	<img alt="" src="../images/punctuation.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 175px;" />Punctuation</h2>
<p>
	Wenn wir so im Internet unterwegs sind, dann gibt es Programme (oder besser Algorithmen) die unsere Sprache automatisch erkennen können.&nbsp; Wir tippen ein paar Wörter und Satzzeichen ein, und schon kann uns das Programm sagen welche Sprache das ist.&nbsp; Wir können so etwas ähnliches auch ganz einfach bewerkstelligen.</p>
<p>
	Die Idee ist es die Satzzeichen, also &quot;;:&#39;&quot;,!?.&quot;, zu zählen.&nbsp; Das machen wir genauso wie im letzten Projekt (Histogram) und zeigen dann die Häufigkeit der Satzzeichen in einem Histogramm.&nbsp;&nbsp; Es stellt sich heraus, das jede Sprache ihre Lieblingssatzzeichen hat, und man an der Verteilung der Satzzeichen eine Sprache erkennen kann, natürlich muss der zu ananlysierende Text lang genug sein, und sollte typisch für die Sprache sein (Ulysses wäre also eher ungeeignet [2]).</p>
<p>
	Der Clou bei diesem Programm ist die Instanzvariable <em>punctuation</em>:</p>
<pre>
    private String punctuation = &quot;;:&#39;<span style="color:#0000ff;">\&quot;</span>,!?.&quot;;</pre>
<p>
	&nbsp;</p>
<p>
	also ein String der alle möglichen Satzzeichen einthält.&nbsp; Wir haben hier das Zeichen &#39;\&quot;&#39; speziell markiert, denn es ist die einzige Möglichkeit wie man das Anführungszeichen in einen String bekommt.</p>
<p>
	Wir lesen dann wieder Zeile für Zeile aus einer Datei die uns der Nutzer genannt hat, und analysieren jede Zeile</p>
<pre>
    private void analyzeForPunctuation(String line) {
        for (int i = 0; i &lt; line.length(); i++) {
            char c = line.charAt(i);
            if (punctuation.contains(&quot;&quot; + c)) {
                int index = punctuation.indexOf(c);
                histogramData[index]++;
                totalNrOfPunctuations++;
            }
        }
    }</pre>
<p>
	Das ist ziemlich schwerer Tabak, aber eigentlich auch wieder nicht.&nbsp; Wir gehen ein Zeichen nach dem anderen durch.&nbsp; Sehen nach ob es ein Satzzeichen ist, und falls ja, erhöhen wir den Zähler für dieses Satzzeichen um eins.&nbsp; Außerdem haben wir noch einen Zähler für die Gesamtzahl der Satzzeichen, das erlaubt uns dann beim Anzeigen der Sternchen die Zahlen zu normieren.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/worldMap.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />WorldMap</h2>
<p>
	Die Wikipedia hat eine Liste mit den Längen- und Breitengraden vieler Städte weltweit [3].&nbsp; Wenn wir diese Liste, &quot;Cities.txt&quot;, durchgehen und für jede Stadt ein GOval malen, dann können wir eine Weltkarte zeichnen.&nbsp; Wir verwenden also wieder die FileReader/BufferedReader Kombo um Zeile für Zeile aus der Datei zu lesen.&nbsp; Die Daten in einer Zeile</p>
<pre>
Germany, Berlin, <span style="color:#0000ff;">52</span>, 32, N, <span style="color:#0000ff;">13</span>, 25, E</pre>
<p>
	müssen wir <em>parsen</em>, d.h. die Information so umformen, dass sie für uns nützlich ist.&nbsp; Für unsere Zwecke sind das Land und der Name der Stadt nutzlos.&nbsp; Mit der Genauigkeit nehmen wir es auch nicht so genau, deswegen genügt uns die Grad Angabe, also die <em>52</em>, z.B..&nbsp; Was wir allerdings noch benötigen ist ob sich die Stadt im Norden oder im Süden der Erdkugel befindet:</p>
<pre>
    String[] data = line.split(&quot;,&quot;);
    String lat1 = data[2].trim();
    String lat3 = data[4].trim();

    int lat = Integer.parseInt(lat1);
    if (lat3.endsWith(&quot;S&quot;)) {
        lat = -lat;
    }</pre>
<p>
	und das Gleiche für die Länge (longitude).&nbsp; Das Ganze skalieren wir noch, damit es in unseren Screen passt, also</p>
<pre>
    double x = (0.5 - lon / 360.0) * WIDTH;
    double y = (0.5 - lat / 180.0) * HEIGHT;
    GOval city = new GOval(CITY_SIZE, CITY_SIZE);
    add(city, x, y);</pre>
<p>
	Sieht doch sehr hübsch aus, oder?</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/editor.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 150px;" />Editor</h2>
<p>
	Im Swing Kapitel haben wir ja schon eine UI für einen Editor geschrieben.&nbsp; Endlich können wir auch Dateien lesen und schreiben.&nbsp; In der Methode <em>saveFile()</em> holen wir uns einfach den Text aus der JTextArea <em>display</em> mittels</p>
<pre>
    String text = display.getText()</pre>
<p>
	und schreiben den Text in einem Stück mittels eines FileWriters in eine Datei.&nbsp; In der Methode <em>openFile()</em> lesen wir Zeile für Zeile aus der Datei und zeigen sie dann in der JTextArea <em>display</em> mittels <em>display.setText(text)</em> an.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/quiz2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 133px;" />Quiz</h2>
<p>
	Auch für unser Quiz Programm steht die UI bereits.&nbsp; Allerdings ist ein Quiz mit nur einer Frage nicht besonders nützlich.&nbsp; Außerdem sollte man verschiedene Quizzes mit unserem Programm halten können.&nbsp;</p>
<p>
	Wir beginnen mit den Fragen.&nbsp; Die sollten aus einer Text Datei kommen, dann kann man nämliche beliebige Quizzes halten.&nbsp; Für unser Beispiel ist das einfach eine Textdatei namens &quot;Quiz.txt&quot;:</p>
<pre>
Correct:  1 + 1 = 2 ?; Yes; No; Maybe
What is 2 ^ 2 ?; 2; 4; 8
A zebra has stripes?; Yes; No</pre>
<p>
	Jede Zeile entspricht einer Frage mit den möglichen Antworten.&nbsp; Die Frage ist an erster Stelle, gefolgt von den möglichen Antworten.&nbsp; Frage und Antworten durch Strichpunkte getrennt.&nbsp; Diese Datei können wir Zeile für Zeile einlesen, und mittels der <em>split()</em> Methode kommen wir an Frage und Antworten:</p>
<p>
	&nbsp;&nbsp;&nbsp; String[] words = line.split(&quot;;&quot;);</p>
<p>
	Aus jeder Zeile machen wir ein Frage:</p>
<pre>
    class Question {
        String question;
        String[] answers;

        public Question(String[] words) {
            question = words[0];
            answers = words;
        }
    }</pre>
<p>
	indem wir einfach dieses Array an den Konstruktor übergeben.&nbsp; Da die Klasse <em>Question</em> nur in unserer Quiz Klasse verwendet wird, kann es eine lokale Klasse sein, muss es aber nicht.</p>
<p>
	Nun ist die Frage, was machen wir mit den Fragen?&nbsp; Wir stecken sie alle in eine ArrayList:</p>
<pre>
    private ArrayList&lt;Question&gt; questions;</pre>
<p>
	Man könnte auch ein Array verwenden, aber dann müsste man im Voraus wissen wieviele Fragen ein Quiz hat, das wissen wir aber nicht.&nbsp; Zusammengefasst sieht das dann so aus:</p>
<pre>
    while (true) {
        String line = rd.readLine();
        if (line == null)
            break;
        String[] words = line.split(&quot;;&quot;);
        Question q = new Question(words);
        questions.add(q);
    }</pre>
<p>
	Kommen wir zum Darstellungsteil unseres Programms.&nbsp; Wir benötigen natürlich eine <em>actionPerformed()</em> Methode für den <em>Previous</em> und <em>Next</em> JButton:</p>
<pre>
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == btnNext) {
            currentQuestion++;
            currentQuestion = currentQuestion % questions.size();
            setQuestion(currentQuestion);
        } else {
            currentQuestion--;
            ...
        }
    }</pre>
<p>
	Wir haben also einen Zähler, <em>currentQuestion</em>, der auf die momentan aktuelle Frage zeigt, also der Index in der ArrayList <em>questions</em>.&nbsp; Was noch bleibt ist die <em>setQuestion()</em> Methode.&nbsp;</p>
<p>
	&nbsp;&nbsp;&nbsp; private void setQuestion(int index) {<br />
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Question q = questions.get(index);<br />
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lbl.setText(q.question);<br />
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;buildMultipleChoiceAnswers(q.answers);<br />
	&nbsp;&nbsp; &nbsp;}</p>
<p>
	Die holt einfach die momentan aktuelle Frage aus der ArrayList, und setzt unser Label mit der Frage und ruft unsere alte <em>buildMultipleChoiceAnswers()</em> Methode mit den Antworten auf.</p>
<p>
	Erweiterungen: Was noch fehlt ist dass die Antworten des Nutzers auch irgendwo gespeichert werden, und am Ende ausgewertet werden.&nbsp; Das ist nicht weiter schwer, braucht aber seine Zeit.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/dictionary.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />Dictionary</h2>
<p>
	Wörterbücher sind eine typische Anwendung für eine HashMap.&nbsp; Als Beispiel wollen wir ein deutsch-englisches Wörterbuch implementieren.&nbsp; Das Wörterbuch halten wir als Instanzvariable:</p>
<pre>
    private HashMap&lt;String, String&gt; dictionary = new HashMap&lt;String, String&gt;();</pre>
<p>
	und im ersten Schritt müssen wir das Wörterbuch initialisieren:</p>
<pre>
    private void initialzeDictionary() {
        dictionary.put(&quot;hund&quot;, &quot;dog&quot;);
        dictionary.put(&quot;katze&quot;, &quot;cat&quot;);
        dictionary.put(&quot;fisch&quot;, &quot;fish&quot;);
    }</pre>
<p>
	Wir fragen dann den Nutzer nach einem deutschen Wort mittels readLine() von der Konsole und der <em>get()</em> Methode</p>
<pre>
    String english = dictionary.get( german.toLowerCase() );</pre>
<p>
	erhalten wir dann das englische Wort.&nbsp; Ganz wichtig, die Übersetzung geht nur in eine Richtung.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/stateLookup.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />StateLookup</h2>
<p>
	Eine andere typische Anwendung für HashMaps ist wenn wir etwas suchen.&nbsp; Z.B. wir haben den Kürzel eines US-Bundesstaates (z.B. &quot;NY&quot;) und würden gerne wissen um welchen Bundesstaat es sich denn handelt.&nbsp; Im Internet findet man Tabellen mit der Liste aller Bundesstaaten, z.B. in der Form:</p>
<pre>
AL,Alabama
AK,Alaska
AZ,Arizona
...</pre>
<p>
	Wir lesen also Zeile für Zeile, und fügen diese in unsere HashMap ein:</p>
<pre>
    private void readStateEntry(String line) {
        int comma = line.indexOf(&quot;,&quot;);
        String stateInitial = line.substring(0, comma).trim();
        String stateName = line.substring(comma + 1).trim();
        states.put(stateInitial, stateName);
    }</pre>
<p>
	(das kann man natürlich auch mit der split() Methode oder dem StringTokenizer machen).&nbsp; Der Rest funktioniert dann genauso wie im Projekt Dictionary.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/VocabularyTrainer.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />VocabularyTrainer</h2>
<p>
	Das Pendant zu einem Dictionary ist ein Vokabel-Trainer.&nbsp; Allerdings soll unser Vokabel-Trainer für beliebige Sprachen funktionieren, deswegen können wir nicht einfach die Vokabeln hardcoden, sondern sollten diese aus einer Datei lesen.&nbsp; In der Datei &quot;Vocabulary.txt&quot; sind die Vokabeln in folgender Form gespeichert:</p>
<pre>
dog,Hund
cat,Katze
fish,Fisch
...</pre>
<p>
	Wir lesen also Zeile für Zeile und speichern die Vokabeln in einer HashMap namens <em>vocabulary</em>:</p>
<pre>
    private HashMap&lt;String, String&gt; vocabulary = new HashMap&lt;String, String&gt;();</pre>
<p>
	Was den Vokabel-Trainer jetzt aber vom Dictionary unterscheidet ist, dass er den Nutzer nach der Übersetzung eines englischen Wortes fragt.&nbsp; Ist die Antwort des Nutzers richtig, dann bekommt ein verbales Klopfen auf die Schulter.&nbsp; Wusste der Nutzer allerdings das Wort nicht, so müssen wir es in einer Liste von <em>unknownWords</em> speichern:</p>
<pre>
    private ArrayList&lt;String&gt; unknownWords = new ArrayList&lt;String&gt;(); </pre>
<p>
	Am Ende sollten wir dann die Liste der Wörter die der Nutzer nicht wusste auflisten, damit er sie noch mal in Ruhe lernen kann.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/vocabularyTrainerSwing.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 160px;" />VocabularyTrainerSwing</h2>
<p>
	Konsolenanwendung sind zwar einfach, aber häßlich.&nbsp; Da wir aber die schwere Arbeit schon im letzten Projekt geschafft haben, machen wir daraus einfach eine Swing Applikation.&nbsp; Die besteht aus einem JLabel im Norden und einem JTextField im Süden.&nbsp; Wir zeigen dem Nutzer das zu übersetzende Wort im JLabel, und der Nutzer soll dann die Übersetzung im JTextField eingeben.&nbsp;</p>
<p>
	Für das Feedback an den Nutzer würden wir gerne eine Dialogfenster verwenden.&nbsp; In Swing geht das mit der <em>JOptionPane</em>:</p>
<pre>
    public void actionPerformed(ActionEvent e) {
        String english = englishLbl.getText();
        String guess = germanTf.getText();
        if (guess.toLowerCase().equals(dictionary.get(english))) {
            <span style="color:#0000ff;">JOptionPane.showMessageDialog(this, &quot;Great job!&quot;,
                    &quot;Check&quot;, JOptionPane.INFORMATION_MESSAGE);</span>
        } else {
            JOptionPane.showMessageDialog(this, &quot;Try again!&quot;,
                    &quot;Check&quot;, JOptionPane.INFORMATION_MESSAGE);
        }

        setRandomWord();
    }</pre>
<p>
	Ansonsten, können wir den Code vom Projekt VocabularyTrainer wiederverwenden.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/trains.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />Trains</h2>
<p>
	Eine sehr schöne Anwengung für HashMaps sind Fahrpläne.&nbsp; Nehmen wir an wir wollen von München nach Berlin und es gibt aber keine direkte Verbindung.&nbsp; Dann sehen wir im Fahrplan nach und sehen, dass man von München nach Nürnberg fahren kann, und von Nürnberg gibt es einen Zug nach Berlin.&nbsp; So eine einfacher Fahrplan könnte einfach eine Textdatei sein, die alle Verbindung enthält:</p>
<pre>
Nuremberg &gt; Berlin
Nuremberg &gt; Frankfurt
Nuremberg &gt; Munich
Munich &gt; Nuremberg
Hamburg &gt; Berlin</pre>
<p>
	Wichtig ist hier, dass die Verbindungen zwischen Städten eine Richtung haben, also der Zug geht von Nürnberg nach Berlin, muss aber nicht zurück gehen.&nbsp;</p>
<p>
	Der nächste Schritt ist sich zu überlegen wie man so einen Fahrplan in einer HashMap unterbringt.&nbsp; Es ist klar, dass der Key der Ausgangsbahnhof sein muss. Da es aber mehrere Zielbahnhöfe geben kann, müssen wir hier eine Liste verwenden:</p>
<pre>
    private HashMap&lt;String, ArrayList&lt;String&gt;&gt; connections;</pre>
<p>
	Außerdem macht es auch noch Sinn eine Liste von allen Bahnhöfen irgendwo zu haben:</p>
<pre>
    private ArrayList&lt;String&gt; cities;</pre>
<p>
	Im <em>setup()</em> lesen wir also den Fahrplan und befüllen unsere beiden Datenstrukturen.&nbsp; Mit dem StringTokenizer trennen wir source von destination:</p>
<pre>
    StringTokenizer st = new StringTokenizer(line, &quot;&gt;&quot;);
    String source = st.nextToken().trim();
    String destination = st.nextToken().trim();</pre>
<p>
	Dann sollten wir checken, ob es den Ausgangsbahnhof schon gibt</p>
<pre>
    if (!cities.contains(source)) {
        cities.add(source);
        connections.put(source, new ArrayList&lt;String&gt;());
    }</pre>
<p>
	und schließlich müssen wir die neue Verbindung hinzufügen:</p>
<pre>
    ArrayList&lt;String&gt; cits = connections.get(source);
    cits.add(destination);
</pre>
<p>
	Nachdem die Daten jetzt geladen sind, können wir mit dem eigentlichen Programm fortfahren.&nbsp; Als erstes sollten wir dem Nutzer eine Liste aller Ausgangsbahnhöfe auflisten.&nbsp; Daraus sollte er seinen Ausgangbahnhof wählen.&nbsp; Im nächsten Schritt listen wir die möglichen Zielbahnhöfe auf, und lassen den Nutzer wieder wählen.&nbsp; Das machen wir so lange, bis der Nutzer seinen Zielbahnhof erreicht hat, also den leeren String eingibt.</p>
<p>
	Erweiterungen: Was natürlich cool wäre, wenn der Nutzer einfach nur seinen Ausgangsbahnhof und Zielbahnhof eingeben könnte, und das Programm dann automatisch eine Route vorschlägt.&nbsp; Gegen Ende des nächsten Semesters können wir das auch.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/adventure.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />Adventure</h2>
<p>
	Auch eine schöne Anwendung für HashMaps sind Abenteuer Spiele.&nbsp; In vielen von diesen text-basierten Spielen geht es darum eine Welt zu erkunden, und Gegenstände einzusammeln.&nbsp; Wir konzentrieren uns hier auf den Erkunden Teil, aber der Einsammel Teil ist auch nicht so schwer.</p>
<p>
	Ähnlich wie beim <em>Trains</em> Projekt benötigen wir eine Beschreibung der Umgebung.&nbsp; Am einfachsten ist da eine Beschreibung unserer Wohnung.&nbsp; Also bei uns zu hause sieht das so aus:</p>
<pre>
hallway &gt; kitchen
hallway &gt; living room
hallway &gt; bath room
kitchen &gt; hallway
living room &gt; hallway
bath room &gt; hallway
bath room &gt; kitchen</pre>
<p>
	Auch hier verwenden wir wieder eine HashMap die den Plan unserer Wohnung wiedergibt:</p>
<pre>
    private HashMap&lt;String, ArrayList&lt;String&gt;&gt; roomMap;</pre>
<p>
	Da es sich um ein Erkundungsspiel handelt, benötigen wir keine Liste aller Räume, anstelle lassen wir den Spieler einfach in der Küche mit seiner Erkundung beginnen.&nbsp; Wir listen dann die Räume auf die von der Küche aus zu erreichen sind, und bitten den Spieler eine Wahl zu treffen.&nbsp; Auf diese Art und Weise kann der Spieler nach und nach unsere ganz Wohnung erkunden.&nbsp; Mit der Eingabe des leeren Strings endet das Spiel.</p>
<p>
	Erweiterungen:&nbsp; Für diesen Spieletyp gibt es zahllose Erweiterungen.&nbsp; Man könnte zum Beispiel die Welt aus StarWars oder Herr der Ringe auf diese Art abbilden.&nbsp; In den verschiedenen Räumen könnte man magische Gegenstände verstecken.&nbsp; Und manche Räume kann man nur betreten wenn man einen bestimmten Gegenstand hat, usw...</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/buildIndex.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />BuildIndex</h2>
<p>
	Bücher aus Papier kann man nicht so leicht durchsuchen wie elektronische Bücher.&nbsp; Deswegen haben die meisten Bücher hinten einen Index, auch Stichwortverzeichnis genannt.&nbsp; Als Beispiel wollen wir eine Liste von Stichwörtern für das Buch &quot;TomSawyer.txt&quot; erstellen.&nbsp;</p>
<p>
	Wie üblich gehen wir Zeile für Zeile durch das Buch und benutzen den StringTokenizer</p>
<pre>
    StringTokenizer st = new StringTokenizer(line, &quot;[]\&quot;&#39;,;:.!?()-/ \t\n\r\f&quot;);</pre>
<p>
	um die Wörter aus eine Zeile zu extrahieren.&nbsp; Das ist eines der wenigen Male wo die <em>split()</em> Methode der String Klasse nicht funktionieren würde (es sei denn man beherrscht Reguläre Ausdrücke).</p>
<p>
	Wir gehen also alle Zeilen und alle Wörter (Tokens) durch und speichern diese in einer HashMap</p>
<pre>
    private Map&lt;String, Integer&gt; words = new HashMap&lt;String, Integer&gt;();</pre>
<p>
	Diese HashMap befüllen wir dann mit der folgenden Methode:</p>
<pre>
    private void addWordToHashMap(String word) {
        if (word != null) {
            if (words.containsKey(word)) {
                int count = words.get(word);
                words.put(word, ++count);
            } else {
                words.put(word, 1);
            }
        }
    }</pre>
<p>
	denn wir wollen zählen, wie häufig ein bestimmtes Wort vorkommt.&nbsp; Jetzt müssen wir nur noch die Map auf der Konsole ausgeben.</p>
<p>
	Erweiterungen:</p>
<ul>
	<li>
		Wenn wir die Liste betrachten, stellen wir fest, dass die meisten Wörter mit weniger als acht Buchstaben eigentlich nichts in einem Index verloren haben.&nbsp; Also sollten wir sie gar nicht in die Liste mit aufnehmen.</li>
	<li>
		Man könnte noch Wörter die im Plural enden herausfiltern (das ist im Englischen relativ einfach)</li>
	<li>
		Man könnte Wörter mit nutzlosen Endungen (im Englischen &quot;ly&quot;, &quot;ial&quot;, &quot;ive&quot;, &quot;ous&quot;, &quot;ed&quot;) herausfiltern.</li>
	<li>
		Man kann auch eine Liste von Stoppwörtern haben und diese dann herausfiltern [6].</li>
	<li>
		Sortieren: wenn wir anstelle von HashMap eine TreeMap verwenden, dann ist der Index auf einmal sortiert.&nbsp; Warum das so ist, lernen wir nächstes Semester.</li>
</ul>
<p>
	.</p>
<h2>
	<img alt="" src="../images/languages.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />Languages</h2>
<p>
	Was ist schon ein Wörterbuch, das von einer Sprache in eine andere übersetzt?&nbsp; Wir wollen ein Wörterbuch, das von einer Sprache in zehn übersetzt!&nbsp; Dazu muss man aber erst mal irgendwo die nötigen Daten finden.&nbsp; Glücklicherweise gibt es auf dem Website zu dem Buch &quot;Introduction to Programming in Java&quot; von Robert Sedgewick und Kevin Wayne [4] (übrigens ein Super-Buch) eine Datei die die Übersetzungen von über 800 englischen Wörter in zehn andere Sprachen enthält [5].</p>
<p>
	Die Datei &quot;Languages.csv&quot; enthält diese Daten:</p>
<pre>
&quot;cat&quot;,&quot;kat&quot;,&quot;kattekop&quot;,&quot;kissa&quot;,<span style="color:#0000ff;">&quot;chat, matou, rosse&quot;</span>,&quot;Katze&quot;,...</pre>
<p>
	Das erste Wort in jeder Zeile ist das englische Wort, gefolgt von der dänischen, der holländischen, usw., Übersetzung.&nbsp; Welche Sprache an welcher Stelle kommt steht in der ersten Zeile der Datei.&nbsp; Die Daten zu parsen wird nicht ganz einfach, wenn wir uns die französische Übersetzung für Katze ansehen, denn es gibt anscheinend mindestens drei Worte für Katze.&nbsp; Aber wenn wir nach Anführungsstrichen mit der <em>indexOf()</em> Methode suchen,</p>
<pre>
    private ArrayList&lt;String&gt; parseLine(String line) {
        ArrayList&lt;String&gt; translations = new ArrayList&lt;String&gt;();
        while (true) {
            int begin = line.indexOf(&quot;\&quot;&quot;);
            if (begin &lt; 0)
                break;
            int end = line.indexOf(&quot;\&quot;&quot;, begin + 1);
            String s = line.substring(begin + 1, end);
            line = line.substring(end + 1);
            translations.add(s);
        }
        return translations;
    }</pre>
<p>
	dann ist das durchaus machbar.&nbsp; Die Methode <em>parseLine()</em> zerlegt also eine Zeile aus unserer Datei, und wandelt sie in eine ArrayList von Strings um.&nbsp; Diese ArrayList enthält also das englische Wort mit all seinen Übersetzungen.&nbsp; Deutsch ist an sechster Stelle, d.h. mit</p>
<pre>
    ArrayList&lt;String&gt; translations = parseLine(line);
    String german = translations.get(5);</pre>
<p>
	erhalten wir die deutsche Übersetzung des Wortes.&nbsp; So parsen ist erledigt.</p>
<p>
	Ähnlich wie bei unserem einfach Dictionary Projekt, wollen wir ja nach Wörtern suchen, und dafür verwenden wir die HashMap:&nbsp;</p>
<pre>
    private Map&lt;String, List&lt;String&gt;&gt; dictionary;</pre>
<p>
	Allerdings speichern wir jetzt eben nicht nur ein Wort pro englischem, sondern zehn, und deswegen steht da auch <em>List&lt;String&gt;</em>.&nbsp; Die Liste zu befüllen ist ganz einfach:</p>
<pre>
    ArrayList&lt;String&gt; translations = parseLine(line);
    dictionary.put(translations.get(0), translations);</pre>
<p>
	Das Übersetzen ist jetzt ganz einfach.&nbsp; Wir müssen nur wissen welche Sprache gewünscht ist (also z.B. 5 für Deutsch) und welches Wort übersetzt werden soll:</p>
<pre>
    private String translate(String english, int lang) {
        List&lt;String&gt; words = dictionary.get(english);
        if (words != null) {
            return words.get(lang);
        }
        return null;
    }</pre>
<p>
	Das <em>if</em> ist nötig um zu verhindern, dass unser Programm abstürzt falls wir nach einem Wort suchen, das nicht in unserer Datenbank ist.&nbsp;</p>
<p>
	Erweiterungen:</p>
<ul>
	<li>
		wie könnte man von jeder der zehn Sprachen in jede andere der zehn Sprachen übersetzen?</li>
	<li>
		könnte man nicht nur Wörter, sondern ganze Sätze übersetzen?</li>
	<li>
		man könnte natürlich auch eine hübsche UI Anwendung dafür schreiben.</li>
</ul>
<p>
	.</p>
<h2>
	<img alt="" src="../images/stock.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 100px;" />StockCharter</h2>
<p>
	Kommen wir zu unserem letzten und größten Projekt: <em>StockCharter</em>.&nbsp; Es geht darum Aktienkurse grafisch darzustellen.&nbsp; Wie üblich fangen wir aber einfach an.&nbsp;</p>
<p>
	In einem ersten Schritt schreiben wir ein ConsoleProgram, das im Süden einen JLabel, ein JTextField und einen JButton hat.&nbsp; Wenn der Nutzer dann einen Aktienkürzel (z.B. &quot;msft&quot;) im Textfeld eingeben und auf den Knopf klickt, sollen im Konsolenteil die Daten zu der jeweiligen Aktie angezeigt werden.&nbsp; Der UI Teil sollte uns inzwischen keine große Mühe bereiten.</p>
<h3>
	1. Aktienkurse</h3>
<p>
	Kommen wir zu den Daten, den Aktienkursen.&nbsp; Es ist überraschend schwer an freie Daten für Aktienkurse zu kommen, aber glücklicherweise hat die Firma QuantQuote historische Kurse für den Standard &amp; Poor&rsquo;s 500 (S&amp;P 500) Aktienindex zur freien Verfügung gestellt [7].&nbsp; In diesem Index sind unter anderem Firmen wie Microsoft (msft), IBM (ibm), Ebay (ebay) und Netflix (nflx) gelistet.&nbsp; Die Daten sind in der Datei &quot;SP500_HistoricalStockDataMonthly.csv&quot; zu finden und sehen wie folgt aus:</p>
<pre>
,20130801,20130703,20130605,20130507,20130409,20130311,20130208,...
...
msft,32.06,33.66,34.59,33.4157,28.5002,27.7355,26.9466,26.2568,...
msi,55.07,57.11,56.9164,56.6377,63.0081,62.0605,59.6717,55.9545,...</pre>
<p>
	D.h., es beginnt mit dem Kürzel der Firma, gefolgt von den Kursen.&nbsp; Den Datum des jeweiligen Kurses kann man der ersten Zeile entnehmen.</p>
<h3>
	2. Datenbank</h3>
<p>
	Der nächste Schritt ist es die Daten einzulesen.&nbsp; Wir beginnen mit der Klasse <em>StockDataBase</em>, die alle Daten enthalten soll, also unsere <em>Datenbank</em>.&nbsp; Wir öffnen die Datei &quot;SP500_HistoricalStockDataMonthly.csv&quot;:</p>
<pre>
    BufferedReader br = new BufferedReader(new FileReader(fileName));
    // first line contains dates:
    String line = br.readLine();
    readDates(line);
    // other lines contain data:
    readStockPrices(br);
    br.close();
</pre>
<p>
	Die erste Zeile enthält den jeweiligen Datum, d.h. wir verarbeiten diese in der Methode <em>readDates()</em> und speichern sie in der Instanzvariable <em>dates</em>:</p>
<pre>
    private List&lt;String&gt; dates = new ArrayList&lt;String&gt;();</pre>
<p>
	Danach lesen wir die ganzen Aktienkurse mit der Methode <em>readStockPrices()</em> Zeile für Zeile ein.&nbsp;</p>
<pre>
    private void readStockPrices(BufferedReader br) throws IOException {
        String line;
        while (true) {
            line = br.readLine();
            if (line == null)
                break;
            StockEntry entry = new StockEntry(line);
            stockDB.put(entry.getSymbol(), entry);
        }
    }</pre>
<p>
	Dabei machen wir aus jeder Zeile einen <em>StockEntry</em>, und speichern diesen in unserer HashMap die alle Aktienkurse enthält ab:</p>
<pre>
    private Map&lt;String, StockEntry&gt; stockDB = new HashMap&lt;String, StockEntry&gt;();
</pre>
<p>
	Ein <em>StockEntry</em> enthält alle Daten die zu einer Aktie gehören, und das sind Name und Kurs:</p>
<pre>
public class StockEntry {
    private String symbol;
    private List&lt;Double&gt; prices;
    ...
}</pre>
<p>
	Die Klasse <em>StockEntry</em> benötigt also einen Konstruktor der eine Zeile parst und die eigenen Instanzvariablen <em>symbol</em> und <em>prices</em> initialisiert:</p>
<pre>
    public StockEntry(String line) {
        String[] sVals = line.split(&quot;,&quot;);
        symbol = sVals[0];
        prices = new ArrayList&lt;Double&gt;();
        for (int i = 1; i &lt; sVals.length; i++) {
            if (sVals[i].equals(&quot;null&quot;)) {
                prices.add(-1.0);
            } else {
                prices.add(Double.parseDouble(sVals[i]));
            }
        }
    }</pre>
<p>
	Außerdem benötigt sie noch eine <em>getSymbol()</em> und eine <em>getPrices()</em> Methode, und natürlich eine <em>toString()</em> Methode wäre auch noch schön.</p>
<p>
	Kommen kurz zurück zur <em>StockDataBase</em> Klasse: der fehlen noch zwei Methoden: <em>findEntry()</em> und <em>getDates()</em>.&nbsp; Die erste der beiden sucht nach einem gegebenen Symbol (z.B. &quot;msft&quot;) und soll den dazugehörigen <em>StockEntry</em> aus der HashMap <em>stockDB</em> zurückliefern, die zweite soll einfach die Liste mit den Dati zurückgeben.</p>
<h3>
	3. Console</h3>
<p>
	Um zu testen, dass unsere Datenbank richtig funktioniert, fügen wir einen ActionListener zu unserem ConsoleProgram hinzu und implementieren die <em>actionPerformed()</em> Methode:</p>
<pre>
    public void actionPerformed(ActionEvent e) {
        StockEntry entry = db.findEntry(tfSymbol.getText());
        if (entry != null) {
            println(entry);
        }
    }</pre>
<p>
	Natürlich mǘssen wir vorher unsere Datenbank mit</p>
<pre>
    db = new StockDataBase(&quot;SP500_HistoricalStockDataMonthly.csv&quot;);</pre>
<p>
	initialisiert haben.&nbsp; Das müsste eigentlich genügen um die Funktionsfähigkeit unserer Datenbank unter Beweis zu stellen.</p>
<h3>
	<img alt="" src="../images/stock2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />4. Grafik</h3>
<p>
	Kommen wir zum Grafikteil.&nbsp; Im erste Schritt, machen wir aus dem <em>ConsoleProgram</em> ein <em>Program</em>.&nbsp; Wir könnten auch ein <em>GraphicsProgram</em> machen, das hat aber gewisse Nachteile wie wir gleich sehen werden.</p>
<p>
	Da ein <em>Program</em> noch keinen Canvas hat, müssen wir selbst für einen sorgen.&nbsp; Wir fügen also zu unserem Hauptprogramm die Instanzvariable <em>canvas</em> hinzu:</p>
<pre>
    private StockCanvas canvas;</pre>
<p>
	und initalisieren diese in der init() Methode:</p>
<pre>
    canvas = new StockCanvas(db.getDates());
&nbsp;&nbsp; &nbsp;add(canvas, CENTER);</pre>
<p>
	d.h. der Canvas bekommt eine Referenz auf die Dati und wir fügen den Canvas in den CENTER Bereich unseres Programms.&nbsp; Ausserdem nehmen wir noch eine kleine Änderung an der <em>actionPerformed()</em> Methode vor:</p>
<pre>
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals(&quot;Graph&quot;)) {
            StockEntry entry = db.findEntry(tfSymbol.getText());
            if (entry != null) {
                <span style="color:#0000ff;">canvas.addEntry</span>(entry);
            }
        } else {
            <span style="color:#0000ff;">canvas.clear</span>();
        }
    }</pre>
<p>
	Wir sehen also drei Anforderungen an unsere <em>StockCanvas</em> Klasse:&nbsp; Der Konstruktor bekommt eine Liste mit Dati, und es muss die Methoden <em>addEntry()</em> und <em>clear()</em> geben.</p>
<pre>
public class StockCanvas extends GCanvas {
    private List&lt;String&gt; dates;
    private ArrayList&lt;StockEntry&gt; entries = new ArrayList&lt;StockEntry&gt;();

&nbsp;&nbsp;&nbsp; public StockCanvas(List&lt;String&gt; dates) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.dates = dates;
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void clear() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entries.clear();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;update();
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;public void addEntry(StockEntry entry) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entries.add(entry);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;update();
&nbsp;&nbsp; &nbsp;}
}</pre>
<p>
	Was jetzt noch fehlt damit alles hübsch wird, ist die <em>update()</em> Methode:</p>
<pre>
    private void update() {
        removeAll();
        drawGrid();
        drawEntries();
    }</pre>
<p>
	Erst wird mal alles gelöscht, dann soll das Hintergrundraster mit den Beschriftungen gezeichnet werden, und darin sollen dann die Aktienkurse gezeichnet werden.&nbsp; Das sind aber &quot;einfach&quot; nur ein paar GLabels und GLines an der richtigen Stelle.</p>
<h3>
	5. Resizing</h3>
<p>
	&quot;One more thing...&quot; wie Steve Jobs zu sagen pflegte: was passiert eigentlich wenn wir die Größe unseres Fensters verändern?&nbsp; Ooops, das sieht aber häßlich aus.&nbsp; Was müssten wir tun, damit das Programm sich bei veränderter Größe neu zeichnet?&nbsp; Dafür gibt es das <em>ComponentListener</em> Interface: unsere <em>StockCanvas</em> Klasse muss dieses implementieren:</p>
<pre>
public class StockCanvas extends GCanvas <span style="color:#0000ff;">implements ComponentListener</span> {
&nbsp;&nbsp;&nbsp; public StockCanvas(List&lt;String&gt; dates) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.dates = dates;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span style="color:#0000ff;">addComponentListener(this);</span>
&nbsp;&nbsp; &nbsp;}
    ...
}</pre>
<p>
	im Konstruktor müssen wir uns selbst als <em>ComponentListener</em> hinzufügen, und es müssen zwingenderweise die folgenden Methoden hinzugefügt werden:</p>
<pre>
    public void componentHidden(ComponentEvent e) {}
    public void componentMoved(ComponentEvent e) {}
    public void componentShown(ComponentEvent e) {}

    public void componentResized(ComponentEvent e) {
        update();
    }</pre>
<p>
	die alle nichts tun außer die letzte.&nbsp; Und das genügt schon, damit unser Programm sich neu zeichnet wenn sich die Größe verändert.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/drawingEditor2.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />DrawingEditor</h2>
<p>
	Wir wollen ein einfaches Zeichenprogramm schreiben.&nbsp; Die Idee ist, dass wir zwischen den Formen Rechteck und Kreis mittels zweier Radiobuttons auswählen können, außerdem wollen wir festlegen können, ob die Formen ausgefüllt sein sollen oder nicht, und natürlich&nbsp; möchten wir noch die Farbe der Formen bestimmen können. Wir wollen aber nicht nur Zeichnen können, wir wollen unsere Kunstwerke auch Speichern und wieder Laden können.&nbsp;</p>
<p>
	Wir beginnen mit der UI.&nbsp; Dazu übernehmen wir einfach unsere Vorarbeiten aus dem Kapitel zu Swing, wo wir bereits die UI für einen solchen DrawingEditor geschrieben haben.&nbsp; Allerdings verschieben wir die Auswahl der Form in den Norden, und im Süden platzieren wir zwei JButtons zum Laden und Speichern.&nbsp;</p>
<p>
	Natürlich soll unser DrawingEditor ein GraphicsProgram sein, sonst wird das nichts mit dem Zeichnen.&nbsp; Da die Formen per Mausklick erzeugt werden sollen, benötigen wir einen MouseListener, und da wir auch auf die JButtons reagieren wollen ist zusätzlich ein ActionListener notwendig.&nbsp; Das alles machen wir in der <em>init()</em> Methode.</p>
<p>
	Da wir später alle unsere Formen (GObjects) speichern wollen, müssen wir sie natürlich im Auge behalten.&nbsp; Das heißt, wir benötigen eine ArrayList als Instanzvariable in die wir alle GObjects hinzufügen:</p>
<pre>
    private ArrayList&lt;GObject&gt; objects = new ArrayList&lt;GObject&gt;();</pre>
<p>
	Arbeiten wir weiter an der <em>mousePressed()</em> Methode.&nbsp; Zunächst müssen wir wissen welche Form gewünscht ist. Wir fragen also die Radiobuttons:</p>
<pre>
    GObject obj;
    if (rBtnRect.isSelected()) {
        obj = new GRect(SIZE, SIZE);
    } else {
        obj = new GOval(SIZE, SIZE);
    }</pre>
<p>
	Dann fragen wir die Combobox nach der Farbe,</p>
<pre>
    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE };
    obj.setColor(colors[cBoxColorPicker.getSelectedIndex()]);</pre>
<p>
	und schließlich sagt uns die Checkbox ob die Formen ausgefüllt sein sollen oder nicht:</p>
<pre>
    GFillable flbl = (GFillable) obj;
    flbl.setFilled(true);</pre>
<p>
	Jetzt können wir die Form zum Canvas hinzufügen, aber wir sollten es zusätzlich in unsere Liste von GObjects einfügen:</p>
<pre>
    objects.add(obj);</pre>
<p>
	Damit ist der Zeichnen Teil geschafft.</p>
<p>
	Kommen wir zum Speichern unserer Kunstwerke.&nbsp; Bisher wenn wir Daten gespeichert haben, dann waren das immer Textdaten.&nbsp; Wie ist das aber mit binären Daten?&nbsp; Dafür gibt es die Klassen <em>FileInputStream</em> und <em>FileOutputStream</em>.&nbsp; Die erste zum Lesen, die zweite zum Schreiben.&nbsp; Das ist schon mal ne tolle Sache.&nbsp; Wer aber den Vogel abschießt, ist der <em>ObjectOutputStream</em>: der macht nämlich aus unseren Objekte serialisierte, binäre Daten.&nbsp; Wir müssen nur sagen <em>writeObject(objects)</em>, und den Rest erledigt der <em>ObjectOutputStream</em>:</p>
<p>
	&nbsp;</p>
<pre>
    private void saveFile(String fileName) {
        try {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));
            oos.<span style="color:#0000ff;">writeObject(objects);</span>
            oos.close();
            println(&quot;Save success.&quot;);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }</pre>
<p>
	Umgekehrt geht das beim Lesen ganz genau so einfach mir <em>readObject()</em>:</p>
<pre>
    private void openFile(String fileName) {
        try {
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
            objects = (ArrayList&lt;GObject&gt;)ois.<span style="color:#0000ff;">readObject()</span>;
            ois.close();
            println(&quot;Load success.&quot;);
            
            // add objects to canvas:
            removeAll();
            for (GObject obj : objects) {
                add(obj);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }</pre>
<p>
	Da der <em>ObjectInputStream</em> ein bischen dumm ist, müssen wir noch einen Cast machen um wieder an unsere GObjects zu kommen.&nbsp; Und natürlich müssen wir die neuen GObjects noch zu unserem Canvas hinzufügen.&nbsp; Aber das war&#39;s dann wieder mal.&nbsp;</p>
<p>
	.</p>
<h2>
	Library</h2>
<p>
	Wir haben gesehen wie man mit Objekt-Orientierte Analyse aus Anforderungen (also Text) eine Programmstruktur mit verschiedenen Klassen erstellen kann.&nbsp; Genau das wollen wir jetzt mit dem Beispiel der Hochschulbibliothek machen:</p>
<p>
	&quot;Die Hochschulbibliothek (Library) hat Studierende und Bücher. Eine Studierende hat einen Namen, eine Immatrikulationsnummer und eine Liste von Büchern die sie ausgeliehen hat. Ein Buch hat einen Autor und einen Titel. Eine Studierende kann Bücher ausleihen, sowie Bücher zurückgeben. Wir können alle Bücher auflisten lassen, die eine Studierende ausgeliehen hat. Wir können neue Studierende anlegen und wir können neue Bücher anlegen.&quot;</p>
<p>
	Es geht also darum die Klassen, Attribute und Methoden der Klassen zu bestimmen.&nbsp; Damit dies aber nicht nur eine theoretische Übung bleibt, wollen wir dann auch einen Schritt weitergehen, und das Programm wirklich schreiben.&nbsp; Hier macht es Sinn sich noch einmal kurz das Projekt <em>InteractiveMenuProgram</em> aus Kaptiel 3 anzusehen.</p>
<p>
	.</p>
<h2>
	Mensa</h2>
<p>
	Das Gleiche was wir für die Hochschulbibliothek getan haben, können wir natürlich auch für die Mensa tun:</p>
<p>
	&quot;Die Mensa hat Gerichte und Zutaten. Ein Gericht hat einen Namen, einen Preis und eine Liste von Zutaten. Eine Zutat hat einen Namen, einen Preis und Kalorien. Es können neue Gerichte angelegt werden, sowie existierende Gerichte gelöscht werden. Wir können alle Zutaten auflisten, die zu einem Gericht gehören. Wir können neue Zutaten anlegen und wir können neue Gerichte anlegen.&quot;</p>
<p>
	Solange wir umsonst arbeiten, werden wir solche Aufträge im Stundenrhythmus erhalten.</p>
<p>
	.</p>
<h2>
	<img alt="" src="../images/numberGuess.png" style="margin-left: 10px; margin-right: 10px; width: 200px; float: right; height: 200px;" />NumberGuess</h2>
<p>
	Bisher haben wir immer alleine programmiert.&nbsp; Was ist aber wenn mehr als eine Person an einem Programm schreiben sollen, wollen oder dürfen?&nbsp; Dafür gibt es Interfaces, also Schnittstellen.&nbsp;</p>
<p>
	Betrachten wir als Beispiel das Spiel NumberGuess.&nbsp; In dem Spiel geht es darum, dass der Computer eine Zufallszahl zwischen 0 und 99 wählt und der Spieler diese möglichst schnell erraten soll.&nbsp; Das Programm besteht aus zwei Teilen: dem Teil der sich um die Logik kümmert (<em>NumberGuessLogic</em>) und den Teil der mit dem Spieler interagiert (<em>NumberGuessConsole</em>).&nbsp; Wir haben also zwei Klassen, die allerdings beide voneinander abhängen.&nbsp; Diese Abhängigkeit wollen wir klar definieren, und das machen wir mittels einer Schnittstelle, also einem Interface:</p>
<pre>
public interface NumberGuessLogic {

&nbsp;&nbsp; &nbsp;/**
&nbsp;&nbsp; &nbsp; * guess should be number between 0 and 99 &lt;br/&gt;
&nbsp;&nbsp; &nbsp; * return 0 if guess was correct &lt;br/&gt;
&nbsp;&nbsp; &nbsp; * return +1 if guess was higher &lt;br/&gt;
&nbsp;&nbsp; &nbsp; * return -1 if guess was lower
&nbsp;&nbsp; &nbsp; */
    public int makeGuess(int guess);
}</pre>
<p>
	Dieses Interface stellt einen Vertrag zwischen zwei Entwicklern dar.&nbsp;</p>
<ul>
	<li>
		Für den einen (<em>NumberGuessConsole</em>) bedeutet es, dass es eine Methode <em>makeGuess(int guess)</em> geben wird, der ich die vom Spieler geratene Zahl übergeben kann, und die mir als Rückgabewert sagt, ob die Zahl zu klein, zu groß oder richtig war (-1, +1, 0).&nbsp;</li>
	<li>
		Für den anderen (<em>NumberGuessLogic</em>) bedeutet es, dass er eine Methode <em>makeGuess(int guess)</em> schreiben muss, die eine Zahl <em>guess</em> mit der intern generierten Zufallszahl vergleicht und dann Rückgabewert liefert der besagt ob die Zahl zu klein, zu groß oder richtig war (-1, +1, 0).</li>
</ul>
<p>
	Dies erlaubt es zwei oder mehr Entwicklern unabhängig voneinander Code für ein Programm zu schreiben, der dann mühelos zusammengefügt werden kann.&nbsp;</p>
<p>
	Sehen wir uns das im Detail an. Wir beginnen mit dem Teil der das Interface <em>NumberGuessLogic</em> implementiert.&nbsp; Häufig nennt man Klassen die nichts anderes tun als ein Interface zu implementieren genauso wie das Interface, hängt aber noch ein &quot;Impl&quot; an den Ende des Namens:</p>
<pre>
public class NumberGuessLogicImpl <span style="color:#0000ff;">implements</span> NumberGuessLogic {
    // instance vars
    // constructor

    public int makeGuess(int guess) {
        ...
    }
}</pre>
<p>
	Diese Klasse muss eine Methode namens <em>makeGuess(int guess)</em> haben, die jetzt natürlich auch etwas tun muss.&nbsp; Und natürlich muss irgendwo die Zufallszahl generiert werden, wahrscheinlich im Konstruktor.</p>
<p>
	Unabhängig davon kann der andere Entwickler bereits beginnen mit <em>NumberGuessConsole</em> Klasse.&nbsp; Dabei handelt es sich um ein ganz normales ConsoleProgram:</p>
<pre>
public class NumberGuessConsole extends ConsoleProgram {

    public void run() {
        <span style="color:#0000ff;">NumberGuessLogic logic = new NumberGuessLogicImpl()</span>;
        ...
        if (logic.makeGuess(guess) == 0) {
            ...
        }
        ...
    }
}</pre>
<p>
	In diesem Programm benutzen wir die <em>NumberGuessLogicImpl</em> Klasse und tun so wie wenn sie schon existieren würde.&nbsp; Wenn dann beide Entwickler fertig sind, fügen wir die Klassen einfach in ein Projekt zusammen, und alles sollte problemlos funktionieren.</p>
<p>
	.</p>
<hr />
<h1>
	Fragen</h1>
<ol>
	<li>
		Schreiben Sie ein Methode countLinesInFile(String fileName), die als Rückgabewert eine Zahl (int) gibt, die die Anzahl der Zeilen in der Datei mit dem Namen &bdquo;fileName&ldquo; beinhaltet. Benutzen Sie dazu die Klassen BufferedReader und FileReader. Sie müssen kein Exception-Handling (try-catch) machen.<br />
		&nbsp;</li>
	<li>
		Schreiben Sie ein Methode readFromFile(String fileName), die als Rückgabewert einen String zurückgibt, der den kompletten Inhalt der Datei mit dem Namen fileName beinhaltet. Benutzen Sie dazu die Klassen BufferedReader und FileReader. Sie müssen kein Exception-Handling (try-catch) machen.<br />
		&nbsp;</li>
	<li>
		Wenn wir von Dateien lesen wollen verwenden wir in der Regel den FileReader.&nbsp; Wenn wir unseren Code schreiben, dann zwingt uns der Compiler immer um den ganzen Code einen &#39;try-catch&#39; Block zu machen.&nbsp; Warum?<br />
		&nbsp;</li>
	<li>
		Im folgenden Code kann es zu Exceptions kommen:<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp; BufferedReader rd = new BufferedReader(new FileReader(&quot;students.txt&quot;));<br />
		&nbsp; while (true) {<br />
		&nbsp; &nbsp;&nbsp; &nbsp;String line = rd.readLine();<br />
		&nbsp; &nbsp;&nbsp; &nbsp;if ( line == null ) break;<br />
		&nbsp; &nbsp;&nbsp; &nbsp;println( line );<br />
		&nbsp; }<br />
		&nbsp; rd.close();</span><br />
		Wie müsste der Code modifiziert werden, also was müsste hinzugefügt werden, damit die Exceptions abgefangen (catch) werden?<br />
		&nbsp;</li>
	<li>
		Was hat es mit dem &quot;null&quot; auf sich?<br />
		&nbsp;</li>
	<li>
		Erklären Sie den Unterschied zwischen einem Array und einer ArrayList.<br />
		&nbsp;</li>
	<li>
		Was ist der größte Nachteil eines Arrays gegenüber einer ArrayList?<br />
		&nbsp;</li>
	<li>
		Nennen Sie zwei Beispiele wofür eine HashMap besser geeignet ist als eine ArrayList.<br />
		&nbsp;</li>
	<li>
		Gibt es einen Unterschied zwischen den beiden Code Beispielen unten?<br />
		<br />
		<span style="font-family:courier new,courier,monospace;">ArrayList&lt;String&gt; nameList = new ArrayList&lt;String&gt;();<br />
		for (String name : nameList) {<br />
		&nbsp;&nbsp; &nbsp;println(&quot; &quot; + name);<br />
		}<br />
		<br />
		ArrayList&lt;String&gt; nameList = new ArrayList&lt;String&gt;();<br />
		for (int i = 0; i &lt; nameList.size(); i++) {<br />
		&nbsp;&nbsp; &nbsp;String name = nameList.get(i);<br />
		&nbsp;&nbsp; &nbsp;println(&quot; &quot; + name);<br />
		}</span><br />
		&nbsp;</li>
	<li>
		Hat ein Array auch Vorteile gegenüber einer ArrayList? Wenn ja, nennen Sie einen.<br />
		&nbsp;</li>
	<li>
		Nennen Sie zwei Beispiele wofür eine HashMap besser geeignet ist als eine ArrayList.<br />
		&nbsp;</li>
	<li>
		Geben Sie zwei Beispiele wofür man HashMaps gut gebrauchen kann.<br />
		&nbsp;</li>
	<li>
		In der folgenden HashMap soll ein Telefonbuch gespeichert werden:<br />
		<span style="font-family:courier new,courier,monospace;">private HashMap&lt;String,Integer&gt; phoneBook = new HashMap&lt;String,Integer&gt;();</span><br />
		Geben Sie kurze Codeschnipsel, die zeigen<br />
		a) wie man ein neue Telefonnummer einfügt,<br />
		b) wie man die Telefonnummer einer Person zugreifen kann und<br />
		c) wie man alle Telefonnummern auflistet.<br />
		&nbsp;</li>
	<li>
		In der folgenden HashMap soll ein englisch-deutsches Wörterbuch gespeichert werden:<br />
		<span style="font-family:courier new,courier,monospace;">private HashMap&lt;String,String&gt; dictionary = new HashMap&lt;String,String&gt;();</span><br />
		Geben Sie kurze Codeschnipsel, die zeigen<br />
		a) wie man ein neues Wortpaar einfügt,<br />
		b) wie man ein für ein gegebenes englisches Wort das entsprechende deutsche liest und<br />
		c) wie man alle Wörter auflistet.<br />
		&nbsp;</li>
	<li>
		&nbsp;Anforderungsanalyse (Requirements):&nbsp; In der Vorlesung haben wir die Anforderung des FlyTunesStore&#39;s analysiert.&nbsp; Benutzen Sie die selbe Technik um die Anforderungen des Journals für angewandte Informatik zu analysieren:<br />
		<br />
		&quot;Das Journal hat Artikel und Ausgaben.&nbsp; Ein Artikel hat einen Autor, einen Titel und einen Text.&nbsp; Eine Ausgabe hat einen Titel, eine Ausgabennummer und Artikel.&nbsp; Wir können alle Artikel auflisten lassen, alle Ausgaben auflisten lassen, sowie die Artikel für eine bestimmte Ausgabennummer.&nbsp; Wir können einen neuen Artikel anlegen und wir können neue Ausgaben anlegen.&quot;<br />
		<br />
		Identifizieren Sie die notwendigen Klassen, Instanzvariablen und Methoden.&nbsp; Ausserdem ordnen Sie die Instanzvariablen und Methoden der richtigen Klasse zu.<br />
		&nbsp;</li>
	<li>
		Gibt es für die Klasse GLabel die &#39;setFilled()&#39; Methode?<br />
		&nbsp;</li>
	<li>
		Was ist der Unterschied zwischen einem &#39;interface&#39; und einer &#39;class&#39;?<br />
		&nbsp;</li>
	<li>
		Wenn wir Grafikobjekte, z.B. GOvals in einem Array speichern wollen, müssen wir bei der Deklaration den Datentyp angeben, also,<br />
		<span style="font-family:courier new,courier,monospace;">&nbsp;&nbsp; &nbsp;&nbsp; GOval[] circles = new GOval[4];</span><br />
		Das bedeutet aber, dass wir nur GOvals in diesem Array speichern dürfen.&nbsp; Wie müssten wir den Code ändern, so dass wir beliebige Objekte (also auch GLine, GRect, etc) in diesem Array speichern dürfen?</li>
</ol>
<p>
	.</p>
<hr />
<h1>
	Referenzen</h1>
<p>
	Auch das letzte Kapitel zehrt von den Referenzen des zweiten Kapitel.&nbsp; Auch ein sehr schönes Buch, das jetzt in Reichweite gerückt ist, ist das von Robert Sedgewick und Kevin Wayne [4].</p>
<p>
	[1] Design by contract, <a href="https://en.wikipedia.org/w/index.php?title=Design_by_contract&amp;oldid=700763992">https://en.wikipedia.org/w/index.php?title=Design_by_contract&amp;oldid=700763992</a> (last visited Feb. 25, 2016).</p>
<p>
	[2] Ulysses, <a href="https://en.wikipedia.org/wiki/Ulysses_(novel)">https://en.wikipedia.org/wiki/Ulysses_(novel)</a></p>
<p>
	[3] Latitude and longitude of cities, A-H, <a href="https://en.wikipedia.org/wiki/Latitude_and_longitude_of_cities,_A-H">https://en.wikipedia.org/wiki/Latitude_and_longitude_of_cities,_A-H</a></p>
<p>
	[4] Introduction to Programming in Java, von Robert Sedgewick und Kevin Wayne</p>
<p>
	[5] Real-World Data Sets, <a href="http://introcs.cs.princeton.edu/java/data/">introcs.cs.princeton.edu/java/data/</a></p>
<p>
	[6] Stoppwort, <a href="https://de.wikipedia.org/wiki/Stoppwort">https://de.wikipedia.org/wiki/Stoppwort</a></p>
<p>
	[7] QuantQuote Free Historical Stock Data, <a href="https://quantquote.com/historical-stock-data">https://quantquote.com/historical-stock-data</a></p>
<p>
	.</p>
<p class="footer">
Copyright &copy; 2016-2021 <a href="http://www.lano.de">Ralph P. Lano</a>.  All rights reserved.
</p>
</div>
</center>
</div>
</body>
</html>